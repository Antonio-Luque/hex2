; Jump to Timer Interrupt
;
; Initialized by the routine at #R$6C00.
; .
; This address belongs to the calculator's memory area and it is pointed by #REGiy+$67 after Spectrum start.
; .
; After #R$6C00 initialization this address stores the instruction 'JP #R$761D' and the interrupt vector address located at $2EFF.
; The value pointed at #HTML(<a href="https://skoolkid.github.io/rom/asm/2DE3.html#2EFE" target="_blank">ROM address $2EFF</a>) is $5CA1.
@label=JUMP_INT
c$5CA1 DEFB $00,$00,$00

; Cyan Queue Area
;
; Read by the routines at #R$7141, #R$7235 and #R$75D5. Updated by the routine at #R$711C.
; .
; 256-aligned block reserved for circular queue.
@label=CYAN_QUEUE_AREA
b$6000 DEFS 256

; Cyan Boards
;
; Initialized by the routine at #R$7103. Read by the routines at #R$7482, #R$74B3, #R$7568, #R$7573, #R$7524, #R$74F1, #R$7141, #R$717D, #R$7235, #R$7277, 
; #R$73AA, #R$73CA, #R$73E5, #R$7403, #R$7422, #R$7440, #R$745B and #R$75A0. Updated by the routines at #R$711C and #R$75BF.
; .
; These boards hold a determined position of the board from cyan perspective. They are used to calculate CYAN "two-
; distance" (Jack van Rijswijck's #HTML(<a href="https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf" target="_blank">thesis</a>))
; from UP to DOWN edges and CYAN two-distance from DOWN to UP edges. The cyan UP-DOWN board is also used to store CYAN
; potentials and TOTAL potentials.
; .
; The values of $7F form the border of the board. The UP and DOWN edges are identified with 7th bit set and the lowest 3
; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a
; flag that indicates a position occupied by a friendly token (stored in 6th bit).
@label=CYAN_BOARD_UP_DOWN
b$6100 DEFB $7F,$7F,$7F,$7F,$7F,$7F,$7F,$7F
 $6108 DEFB $7F,$00,$00,$00,$00,$00,$00,$00
 $6110 DEFB $7F,$7F,$00,$00,$00,$00,$00,$00
 $6118 DEFB $00,$7F,$7F,$00,$00,$00,$00,$00
 $6120 DEFB $00,$00,$7F,$7F,$00,$00,$00,$00
 $6128 DEFB $00,$00,$00,$7F,$7F,$00,$00,$00
 $6130 DEFB $00,$00,$00,$00,$7F,$7F,$00,$00
 $6138 DEFB $00,$00,$00,$00,$00,$7F,$7F,$00
 $6140 DEFB $00,$00,$00,$00,$00,$00,$7F,$7F
 $6148 DEFB $80,$81,$82,$83,$84,$85,$86,$7F
@label=CYAN_BOARD_DOWN_UP
 $6150 DEFB $7F,$00,$00,$00,$00,$00,$00,$00
 $6158 DEFB $7F,$7F,$00,$00,$00,$00,$00,$00
 $6160 DEFB $00,$7F,$7F,$00,$00,$00,$00,$00
 $6168 DEFB $00,$00,$7F,$7F,$00,$00,$00,$00
 $6170 DEFB $00,$00,$00,$7F,$7F,$00,$00,$00
 $6178 DEFB $00,$00,$00,$00,$7F,$7F,$00,$00
 $6180 DEFB $00,$00,$00,$00,$00,$7F,$7F,$00
 $6188 DEFB $00,$00,$00,$00,$00,$00,$7F,$7F
 $6190 DEFB $7F,$7F,$7F,$7F,$7F,$7F,$7F

; Potentials
;
; These metrics are calculated by the routine at #R$74F1. Updated by the routines at #R$7482 and #R$74B3. Read by the routine at #R$74E1.
; .
; #TABLE(default,centre)
; { =h Byte | =h Contents }
; { 0 | Board potential }
; { 1 | Attack mobility }
; TABLE#
@label=POTENTIALS
b$6197 DEFB $00,$00

; AI Player
;
; Initialized by the routine at #R$6F7F. Read by the routines at #R$747B, #R$6FB4, #R$700E, #R$7052, #R$70AC, #R$7568 and #R$7573.
; .
; Holds speccy side from the perspective of the cyan player:
; .
; #TABLE(default,centre)
; { =h Value | =h Side }
; { $02 | FRIEND }
; { $7E | ENEMY }
; TABLE#
@label=AI_PLAYER
b$6199 DEFB $00

; AI Depth
;
; Initialized by the routine at #R$6CEC. Updated by the routines at #R$6FB4, #R$700E, #R$7052 and #R$70AC.
; .
; Holds the recursion depth level: 1-4.
@label=AI_DEPTH
b$619A DEFB $00

; Move Number
;
; Initialized by the routine at #R$6C4B. Read by the routine at #R$6CEC. Updated by the routine at #R$6C83.
; .
; Holds the current move number.
@label=MOVE_NUMBER
b$619B DEFB $00

; Level Color
;
; Read by the routine at #R$78EB. Updated by the routine at #R$7918.
; .
; Current level color for frame border.
@label=LEVEL_COLOR
b$619C DEFB $00

; Game Level
;
; Read by the routines at #R$7918 and #R$6CEC. Updated by the routines at #R$7974, #R$7B5A, #R$6C33 and #R$7875.
; .
; Current game level: 1-4
@label=GAME_LEVEL
b$619D DEFB $00

; Hexagon/Token Color
;
; Read by the routines at #R$6E0F, #R$6F0E, #R$6F15, #R$6F2E, #R$6F35, #R$6F3C, #R$6E2B, #R$70ED, #R$6C83, #R$6CB9 and #R$75A0.
; Updated by the routines at #R$7C4E, #R$6DA1, #R$6C83, #R$79F7, #R$7AA3, #R$7B5A, #R$77D9, #R$6C4B and #R$75D5.
; .
; Current hexagon/token color attribute.
; .
; #TABLE(default,centre)
; { =h Value | =h Color }
; { $02 | RED }
; { $05 | CYAN }
; { $07 | WHITE }
; TABLE#
@label=TOKEN_COLOR
b$619E DEFB $00

; Player Color
;
; Read by the routines at #R$6EF1, #R$6C83 and #R$6CB9. Updated by the routine at #R$6C4B.
; .
; Current player color.
; .
; #TABLE(default,centre)
; { =h Value | =h Color }
; { $02 | RED }
; { $05 | CYAN }
; TABLE#
@label=PLAYER_COLOR
b$619F DEFB $05

; Board Map
;
; Read by the routine at #R$6DD7.
; .
; Screen addresses look-up table for board hexagons.
; .
; The first column contains the screen addresses high byte. The rest of bytes are the screen addresses low byte.
@label=BOARD_MAP
b$61A0 DEFB $40,$A6,$A8,$AA,$AC,$AE,$B0,$B2
 $61A8 DEFB $40,$E7,$E9,$EB,$ED,$EF,$F1,$F3
 $61B0 DEFB $48,$28,$2A,$2C,$2E,$30,$32,$34
 $61B8 DEFB $48,$69,$6B,$6D,$6F,$71,$73,$75
 $61C0 DEFB $48,$AA,$AC,$AE,$B0,$B2,$B4,$B6
 $61C8 DEFB $48,$EB,$ED,$EF,$F1,$F3,$F5,$F7
 $61D0 DEFB $50,$2C,$2E,$30,$32,$34,$36,$38

; Keyboard Map
;
; Read by the routine at #R$6EC5.
; .
; ASCII codes keyboard mapping.
@label=KEY_MAP
t$61D8 DEFM " zxcvasdfgqwert1234509876poiuy\x0Dlkjh  mnb"

; Cyan Vector Table
;
; Read by the routine at #R$7277.
; .
; Vector table of routines for update the two-distance of cyan adjacent positions.
@label=CYAN_VECTOR_TABLE
w$6200 DEFW $73AA
 $6202 DEFW $73CA
 $6204 DEFW $73E5
 $6206 DEFW $7403
 $6208 DEFW $7422
 $620A DEFW $7440
 $620C DEFW $745B

; Char Counter (unused)
@label=CHAR_COUNT
u$620E DEFB $00 ; this cames from an older version of routine at #R$6E2B

; Three-row Counter
;
; Initialized by the routine at #R$6C1D. Read by the routine at #R$78EB. Updated by the routine at #R$6CB9.
; .
; Current three-in-a-row counter.
@label=THREE_ROW
b$620F DEFB $00

; Row Color Map
;
; Read by the routine at #R$7918.
; .
; Level-color map for frame border.
@label=ROW_COLOR_MAP
b$6210 DEFB $0F ; frame border WHITE (level 1)
 $6211 DEFB $0E ; frame border YELLOW (level 2)
 $6212 DEFB $0C ; frame border GREEN (level 3)
 $6213 DEFB $0B ; frame border MAGENTA (level 4)

; Frame Border Cyan (unused)
u$6214 DEFB $0D ; for test purposes

; Frame Border Red (unused)
u$6215 DEFB $0A ; for test purposes

; Formatted Move
;
; Read by the routines at #R$6F3C and #R$6D36. Updated by the routines at #R$6E2B and #R$6CEC.
; .
; Holds players' move as a formatted string
; .
; #TABLE(default,centre)
; { =h Byte | =h Contents }
; { 0 | Column ('a'..'g') }
; { 1 | '-' }
; { 2 | '0' }
; { 3 | Row ('1'..'7') }
; { 4 | '\0' }
; TABLE#
@label=STR_MOVE
b$6216 DEFB $00,'-','0',$00,'\0'

; Game Strings
;
; Read by the routines at #R$7781, #R$6EF1, #R$6F0E, #R$6F2E, #R$6F35, #R$6D36 and #R$6CB9.
@label=STR_SPECCY
t$621B DEFM "Speccy\0"
@label=STR_PLAYER
 $6222 DEFM "Player\0"
@label=STR_LEVELTEXT
 $6229 DEFM "Level\0"
@label=STR_FILLED
 $622F DEFM "FILLED\0"
@label=STR_WAIT
 $6236 DEFM "WAIT\0"
@label=STR_WINNER
 $623B DEFM " WINS \0"
@label=STR_EMPTY4
 $6242 DEFM "    \0"
@label=STR_EMPTY6
 $6247 DEFM "      \0"

; Board Coordinates
;
; Read by the routines at #R$6D36 and #R$6D81.
; .
; Conversion table: from position to XY board indexes.
@label=BOARD_COORDINATES
b$624E DEFB $00,$00,$00,$00,$00,$00,$00,$00
 $6256 DEFB $00,$09,$0A,$0B,$0C,$0D,$0E,$0F
 $625E DEFB $00,$12,$13,$14,$15,$16,$17,$18
 $6266 DEFB $00,$1B,$1C,$1D,$1E,$1F,$20,$21
 $626E DEFB $00,$24,$25,$26,$27,$28,$29,$2A
 $6276 DEFB $00,$2D,$2E,$2F,$30,$31,$32,$33
 $627E DEFB $00,$36,$37,$38,$39,$3A,$3B,$3C
 $6286 DEFB $00,$3F,$40,$41,$42,$43,$44,$45

; Frame Map
;
; Read by the routine at #R$7781.
; .
; Graphics map indexes for #R$650E.
@label=FRAME_MAP
b$628E DEFB $00,$01,$01,$01,$01,$01,$02,$03
 $6296 DEFB $04,$FF,$FF,$FF,$FF,$FF,$FF,$FF
 $629E DEFB $05,$06,$07,$01,$01,$01,$01,$01
 $62A6 DEFB $01,$01,$01,$01,$01,$01,$01,$08
 $62AE DEFB $09,$01,$01,$01,$01,$01,$01,$01
 $62B6 DEFB $01,$01,$01,$01,$01,$01,$01,$01
 $62BE DEFB $0A,$06,$0D,$0D,$0D,$03,$0B,$01
 $62C6 DEFB $01,$01,$01,$01,$01,$01,$01,$0C

; Openings
;
; Read by the routine at #R$6CEC.
; .
; Definition of a small "Opening Book" for speccy first move.
@label=OPENINGS
b$62CE DEFB $0F,$14,$16,$17,$18,$1C,$1D,$1E
 $62D6 DEFB $1F,$20,$24,$25,$26,$27,$28,$29
 $62DE DEFB $2A,$2E,$2F,$30,$31,$32,$36,$37
 $62E6 DEFB $38,$3A,$3F

; Timer Flag
;
; Read by the routines at #R$761D and #R$7650. Updated by the routines at #R$769D, #R$6D36, #R$6CEC and #R$6C83.
; .
; #TABLE(default,centre)
; { =h Value | =h Effect }
; { $00 | Timers stopped }
; { $01 | Cyan timer On }
; { $02 | Red timer On }
; TABLE#
@label=TIMER_FLAG
b$62E9 DEFB $00

; Timer Counters
;
; Read by the routines at #R$761D and #R$7650. Updated by the routine at #R$76B2.
; .
; #TABLE(default,centre)
; { =h Byte | =h Contents }
; { 0 | Interrupt counter (decremented each 1/50 seconds) }
; { 1 | Seconds counter }
; { 2 | Minutes counter }
; TABLE#
@label=CYAN_TIMER
b$62EA DEFB $32,$00,$00
@label=RED_TIMER
 $62ED DEFB $32,$00,$00

; Numbers Screen
;
; Read by the routine at #R$7742.
; .
; Screen addresses look-up array for #R$66A4.
@label=NUMBER_SCREEN
w$62F0 DEFW $43A5,$43E6,$4B27,$4B68,$4BA9,$4BEA,$532B

; Filler #1 (unused)
@label=FILLER_1
u$62FE DEFB $FF,$FF ; filler to align next block (not used)

; Red Queue Area
;
; Read by the routines at #R$71B5, #R$7235 and #R$75D5. Updated by the routine at #R$711C.
; .
; 256-aligned block reserved for circular queue.
@label=RED_QUEUE_AREA
b$6300 DEFS 256

; Red Boards
;
; Initialized by the routine at #R$7103. Read by the routines at #R$7482, #R$74B3, #R$7568, #R$7573, #R$7524, #R$74F1, #R$71B5, #R$71F7,
; #R$7235, #R$7277, #R$7290, #R$72BE, #R$72E4, #R$730A, #R$7330, #R$7356, #R$737C and #R$75A0. Updated by the routines at #R$711C and #R$75BF.
; .
; These boards hold a determined position of the board from red perspective. They are used to calculate RED "two-
; distance" (Jack van Rijswijck) from LEFT to RIGHT edges and RED two-distance from RIGHT to LEFT edges. The red
; LEFT-RIGHT board is also used to store RED potentials.
; .
; The values of $7F form the border of the board. The LEFT-RIGHT edges are identified with Bit 7 set and the lowest 3
; bits are the edge number. The rest of bytes indicates "two-distance" from goal (stored in lowest 6 bits), and a flag
; that indicates a position occupied by a friendly token (stored in 6th bit).
@label=RED_BOARD_LEFT_RIGHT
b$6400 DEFB $7F,$7F,$7F,$7F,$7F,$7F,$7F,$7F
 $6408 DEFB $7F,$00,$00,$00,$00,$00,$00,$00
 $6410 DEFB $80,$7F,$00,$00,$00,$00,$00,$00
 $6418 DEFB $00,$81,$7F,$00,$00,$00,$00,$00
 $6420 DEFB $00,$00,$82,$7F,$00,$00,$00,$00
 $6428 DEFB $00,$00,$00,$83,$7F,$00,$00,$00
 $6430 DEFB $00,$00,$00,$00,$84,$7F,$00,$00
 $6438 DEFB $00,$00,$00,$00,$00,$85,$7F,$00
 $6440 DEFB $00,$00,$00,$00,$00,$00,$86,$7F
 $6448 DEFB $7F,$7F,$7F,$7F,$7F,$7F,$7F,$7F
@label=RED_BOARD_RIGHT_LEFT
 $6450 DEFB $80,$00,$00,$00,$00,$00,$00,$00
 $6458 DEFB $7F,$81,$00,$00,$00,$00,$00,$00
 $6460 DEFB $00,$7F,$82,$00,$00,$00,$00,$00
 $6468 DEFB $00,$00,$7F,$83,$00,$00,$00,$00
 $6470 DEFB $00,$00,$00,$7F,$84,$00,$00,$00
 $6478 DEFB $00,$00,$00,$00,$7F,$85,$00,$00
 $6480 DEFB $00,$00,$00,$00,$00,$7F,$86,$00
 $6488 DEFB $00,$00,$00,$00,$00,$00,$7F,$7F
 $6490 DEFB $7F,$7F,$7F,$7F,$7F,$7F,$7F

; Timer Digits
;
; Read by the routine at #R$7650.
; .
; Timer digits graphics.
@label=TIMER_DIGITS
b$6497 DEFB $00,$0F,$0B,$0B,$0B,$0F,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $649F DEFB $00,$06,$0E,$06,$06,$06,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $64A7 DEFB $00,$0F,$03,$0F,$08,$0F,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $64AF DEFB $00,$0F,$03,$07,$03,$0F,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $64B7 DEFB $00,$0B,$0B,$0F,$03,$03,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $64BF DEFB $00,$0F,$08,$0F,$03,$0F,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $64C7 DEFB $00,$0F,$0C,$0F,$0D,$0F,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $64CF DEFB $00,$0F,$03,$03,$03,$03,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $64D7 DEFB $00,$0F,$0B,$0F,$0B,$0F,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $64DF DEFB $00,$0F,$0B,$0F,$03,$0F,$00,$00 ; #UDG(#PC,attr=7,scale=2)

; Tone Parameters
;
; Read by the routines at #R$7875, #R$6D36, #R$6C83 and #R$75D5.
; .
; Tone parameters for sound effects.
; .
; #TABLE(default,centre)
; { =h Word | =h Contents }
; { 0 | Number of frames in the block, slide changes applied once per frame (1..65536) }
; { 1 | Length of a frame (1..65536) }
; { 2 | Tone pitch, lower numbers for lower tone (1..65536) }
; { 3 | Pitch slide, this value is added to pitch every frame (-32768..32767) }
; TABLE#
@label=TOKEN_FX
w$64E7 DEFW $0001,$03E8,$0578,$0000
@label=WINNER_FX
 $64EF DEFW $0005,$1388,$00C8,$0064
@label=FILLED_FX
 $64F7 DEFW $03E8,$000A,$0064,$0000

; Filler #2 (unused)
@label=FILLER_2
u$64FF DEFB $FF ; filler to align next block (not used)

; Red Vector Table
;
; Read by the routine at #R$7277.
; .
; Vector table of routines for update the two-distance of red adjacent positions.
@label=RED_VECTOR_TABLE
w$6500 DEFW $7290
 $6502 DEFW $72BE
 $6504 DEFW $72E4
 $6506 DEFW $730A
 $6508 DEFW $7330
 $650A DEFW $7356
 $650C DEFW $737C

; Frame Tiles
;
; Read by the routines at #R$6F68 and #R$7781.
; .
; Graphics for the screen frame.
@label=FRAME_TILES
b$650E DEFB $00,$00,$1F,$3F,$3F,$3F,$3C,$3C ; #UDG(#PC,attr=7,scale=2)
 $6516 DEFB $00,$00,$FF,$FF,$FF,$FF,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $651E DEFB $00,$00,$FF,$FE,$FE,$FF,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $6526 DEFB $03,$07,$0F,$0F,$0F,$0F,$07,$03 ; #UDG(#PC,attr=7,scale=2)
 $652E DEFB $FF,$FE,$FC,$FC,$FC,$FC,$FE,$FF ; #UDG(#PC,attr=7,scale=2)
 $6536 DEFB $FF,$7F,$3F,$3F,$3F,$3F,$7F,$FF ; #UDG(#PC,attr=7,scale=2)
 $653E DEFB $C0,$E0,$F0,$F0,$F0,$F0,$E0,$C0 ; #UDG(#PC,attr=7,scale=2)
 $6546 DEFB $00,$00,$FF,$7F,$7F,$FF,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $654E DEFB $00,$00,$F8,$FC,$FC,$FC,$3C,$3C ; #UDG(#PC,attr=7,scale=2)
 $6556 DEFB $3C,$3C,$3F,$3F,$3F,$1F,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $655E DEFB $00,$00,$FE,$FF,$FF,$FE,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $6566 DEFB $00,$00,$7F,$FF,$FF,$7F,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $656E DEFB $3C,$3C,$FC,$FC,$FC,$F8,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $6576 DEFB $00,$00,$38,$7C,$7C,$38,$00,$00 ; #UDG(#PC,attr=7,scale=2)

; Hexagon Sprites
;
; Read by the routines at #R$7C4E, #R$6DA1, #R$79F7, #R$7AA3, #R$7B5A, #R$77D9 and #R$6DBC.
@label=HEXAGON_EMPTY
b$657E DEFB $07,$E0,$18,$18,$20,$04,$24,$04 ; {#UDGARRAY2((#PC)-(#EVAL(#PC+31))-1-16,7,2)(hex-sprite-#PC)
 $6586 DEFB $48,$02,$48,$02,$40,$02,$40,$02 ;
 $658E DEFB $40,$02,$40,$02,$40,$12,$40,$12 ;
 $6596 DEFB $20,$24,$20,$04,$18,$18,$07,$E0 ; }
@label=HEXAGON_SPRITE
 $659E DEFB $03,$C0,$0C,$30,$10,$08,$12,$08 ; {#UDGARRAY2((#PC)-(#EVAL(#PC+31))-1-16,7,2)(hex-sprite-#PC)
 $65A6 DEFB $24,$04,$24,$04,$20,$04,$20,$04 ;
 $65AE DEFB $20,$04,$20,$04,$20,$24,$20,$24 ;
 $65B6 DEFB $10,$48,$10,$08,$0C,$30,$03,$C0 ; }
 $65BE DEFB $01,$80,$02,$40,$04,$20,$09,$10 ; {#UDGARRAY2((#PC)-(#EVAL(#PC+31))-1-16,7,2)(hex-sprite-#PC)
 $65C6 DEFB $0A,$10,$0A,$10,$08,$10,$08,$10 ;
 $65CE DEFB $08,$10,$08,$10,$08,$50,$08,$50 ;
 $65D6 DEFB $08,$90,$04,$20,$02,$40,$01,$80 ; }
 $65DE DEFB $00,$80,$00,$80,$00,$80,$00,$80 ; {#UDGARRAY2((#PC)-(#EVAL(#PC+31))-1-16,7,2)(hex-sprite-#PC)
 $65E6 DEFB $00,$80,$00,$80,$00,$80,$00,$80 ;
 $65EE DEFB $00,$80,$00,$80,$00,$80,$00,$80 ;
 $65F6 DEFB $00,$80,$00,$80,$00,$80,$00,$80 ; }
 $65FE DEFB $01,$80,$02,$40,$05,$A0,$0B,$D0 ; {#UDGARRAY2((#PC)-(#EVAL(#PC+31))-1-16,7,2)(hex-sprite-#PC)
 $6606 DEFB $0B,$D0,$0B,$D0,$0B,$D0,$0B,$D0 ;
 $660E DEFB $0B,$D0,$0B,$D0,$0B,$D0,$0B,$D0 ;
 $6616 DEFB $0B,$D0,$05,$A0,$02,$40,$01,$80 ; }
 $661E DEFB $03,$C0,$0C,$30,$13,$C8,$17,$E8 ; {#UDGARRAY2((#PC)-(#EVAL(#PC+31))-1-16,7,2)(hex-sprite-#PC)
 $6626 DEFB $2F,$F4,$2F,$F4,$2F,$F4,$2F,$F4 ;
 $662E DEFB $2F,$F4,$2F,$F4,$2F,$F4,$2F,$F4 ;
 $6636 DEFB $17,$E8,$13,$C8,$0C,$30,$03,$C0 ; }
@label=HEXAGON_TOKEN
 $663E DEFB $07,$E0,$18,$18,$27,$E4,$2F,$F4 ; {#UDGARRAY2((#PC)-(#EVAL(#PC+31))-1-16,7,2)(hex-sprite-#PC)
 $6646 DEFB $5F,$FA,$5F,$FA,$5F,$FA,$5F,$FA ;
 $664E DEFB $5F,$FA,$5F,$FA,$5F,$FA,$5F,$FA ;
 $6656 DEFB $2F,$F4,$27,$E4,$18,$18,$07,$E0 ; }

; Letter Sprites
;
; Read by the routine at #R$7716.
; .
; Sprites for the two rows of letters on the screen (a..g).
@label=LETTER_SPRITES
b$665E DEFB $3C,$7E,$FF,$C3,$F3,$C3,$D3,$C3 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,5){0,0,0,20}(letter-#PC)
 $6666 DEFB $7E,$3C                         ; }
 $6668 DEFB $3C,$7E,$CF,$CF,$C3,$CB,$CB,$C3 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,5){0,0,0,20}(letter-#PC)
 $6670 DEFB $7E,$3C                         ; }
 $6672 DEFB $3C,$7E,$FF,$E3,$CF,$CF,$CF,$E3 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,5){0,0,0,20}(letter-#PC)
 $667A DEFB $7E,$3C                         ; }
 $667C DEFB $3C,$7E,$F3,$F3,$C3,$D3,$D3,$C3 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,5){0,0,0,20}(letter-#PC)
 $6684 DEFB $7E,$3C                         ; }
 $6686 DEFB $3C,$7E,$FF,$E3,$CB,$C3,$CF,$E3 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,5){0,0,0,20}(letter-#PC)
 $668E DEFB $7E,$3C                         ; }
 $6690 DEFB $3C,$7E,$E3,$CF,$C7,$CF,$CF,$CF ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,5){0,0,0,20}(letter-#PC)
 $6698 DEFB $7E,$3C                         ; }
 $669A DEFB $3C,$7E,$FF,$E3,$D3,$D3,$E3,$F3 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,5){0,0,0,20}(letter-#PC)
 $66A2 DEFB $46,$3C                         ; }

; Number Sprites
;
; Read by the routine at #R$7742.
; .
; Sprites for the two columns of numbers on the screen (1..7).
@label=NUMBER_SPRITES
b$66A4 DEFB $3C,$7E,$E7,$C7,$E7,$E7,$E7,$E7 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,2){0,0,0,20}(number-#PC)
 $66AC DEFB $7E,$3C                         ; }
 $66AE DEFB $3C,$7E,$E7,$D3,$F3,$E7,$CF,$C3 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,2){0,0,0,20}(number-#PC)
 $66B6 DEFB $7E,$3C                         ; }
 $66B8 DEFB $3C,$7E,$C7,$F3,$E3,$F3,$F3,$C7 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,2){0,0,0,20}(number-#PC)
 $66C0 DEFB $7E,$3C                         ; }
 $66C2 DEFB $3C,$7E,$D3,$D3,$C3,$F3,$F3,$F3 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,2){0,0,0,20}(number-#PC)
 $66CA DEFB $7E,$3C                         ; }
 $66CC DEFB $3C,$7E,$C3,$CF,$C7,$F3,$F3,$C7 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,2){0,0,0,20}(number-#PC)
 $66D4 DEFB $7E,$3C                         ; }
 $66D6 DEFB $3C,$7E,$E3,$CF,$C3,$CB,$CB,$C3 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,2){0,0,0,20}(number-#PC)
 $66DE DEFB $7E,$3C                         ; }
 $66E0 DEFB $3C,$7E,$C3,$F3,$F3,$E7,$E7,$E7 ; {#UDGARRAY1,scale=2((#PC)-(#EVAL(#PC+9))-8,2){0,0,0,20}(number-#PC)
 $66E8 DEFB $7E,$3C                         ; }

; Menu Hexagons
;
; Read by the routines at #R$7C4E, #R$79F7, #R$7AA3 and #R$7B5A.
; .
; Screen addresses for the main menu hexagons and sample boards.
@label=MENU_HEXAGONS
w$66EA DEFW $4001,$4005,$4008,$400C,$400F,$4013,$401A
 $66F8 DEFW $4045,$4048,$4052,$405D,$4081,$4083,$4085
 $6706 DEFW $4088,$408A,$4091,$409D,$40C1,$40D0,$40D9
 $6714 DEFW $4805,$4808,$480A,$4813,$4819,$481B,$481D
 $6722 DEFW $400A,$4059,$40BB,$40C5,$40D2,$480C,$401C
 $6730 DEFW $4041,$4050,$40C8,$4801,$480F
@label=SAMPLE_BOARD_RED
 $673A DEFW $4869,$486B,$482C,$482E,$40EF,$40F1,$40B2
 $6748 DEFW $40E9,$486F,$4830,$40F3,$48AA,$40AC,$48EF
 $6756 DEFW $482A,$486D,$40ED,$48AE
@label=SAMPLE_BOARD_CYAN
 $675E DEFW $40AE,$40EF,$4830,$486F,$48AE,$48EF,$502E
 $676C DEFW $48AC,$48B4,$486B,$486D,$482E,$40F1,$40F3
 $677A DEFW $4873,$48B2,$5030

; Program Strings
;
; Read by the routines at #R$7974, #R$7BDE, #R$79F7, #R$7AA3, #R$7B5A and #R$7875.
@label=STR_OPTIONS
t$6780 DEFM "Start new game\0"
 $678F DEFM "How to play\0"
 $679B DEFM "Credits\0"
@label=STR_CREDITS
 $67A3 DEFM "Design:     Antonio Luque\0"
 $67BD DEFM "Code:       Antonio Luque\0"
 $67D7 DEFM "            Einar Saukas\0"
 $67F0 DEFM "Font:       Einar Saukas\0"
 $6809 DEFM "Graphics:   Einar Saukas\0"
 $6822 DEFM "            Antonio Luque\0"
@label=STR_PRESSKEY
 $683C DEFM "Press any key\0"
@label=STR_BUTTONS
 $684A DEFM "Next\0"
 $684F DEFM "Back\0"
@label=STR_RED
 $6854 DEFM "RED\0"
@label=STR_CYAN
 $6858 DEFM "CYAN\0"
@label=STR_HELP1
 $685D DEFM "Connect\0"
@label=STR_HELP2_RED
 $6865 DEFM "left and\0"
@label=STR_HELP2_CYAN
 $686E DEFM "up and\0"
@label=STR_HELP3_RED
 $6875 DEFM "right\0"
@label=STR_HELP3_CYAN
 $687B DEFM "down\0"
@label=STR_HELP4
 $6880 DEFM "borders\0"
@label=STR_HELP5
 $6888 DEFM "to win\0"
@label=STR_HELP
 $688F DEFM "Win three\0"
 $6899 DEFM "times in\0"
 $68A2 DEFM "a row to\0"
 $68AB DEFM "level up\0"
@label=STR_CONGRATS
 $68B4 DEFM " CONGRATULATIONS \0"
@label=STR_LAST_LEVEL
 $68C6 DEFM "Well done! Last level passed\0"
 $68E3 DEFM "Choose level to restart, 1-4\0"

; Character Set
;
; Read by the routine at #R$6F65.
; .
; Based on #HTML(<a href="https://spectrumcomputing.co.uk/entry/25245/ZX-Spectrum/ZX-ALFA" target="_blank">King</a>) this font was designed by Einar Saukas for Hex game.
@label=FONT
b$6900 DEFB $00,$00,$00,$00,$00,$00,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $6908 DEFB $00,$18,$18,$18,$00,$18,$18,$00 ; #UDG(#PC,attr=7,scale=2)
 $6910 DEFB $00,$24,$24,$00,$00,$00,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $6918 DEFB $00,$24,$7E,$24,$24,$7E,$24,$00 ; #UDG(#PC,attr=7,scale=2)
 $6920 DEFB $00,$08,$3E,$28,$3E,$0A,$3E,$08 ; #UDG(#PC,attr=7,scale=2)
 $6928 DEFB $00,$62,$64,$08,$10,$26,$46,$00 ; #UDG(#PC,attr=7,scale=2)
 $6930 DEFB $00,$10,$28,$10,$2A,$44,$3A,$00 ; #UDG(#PC,attr=7,scale=2)
 $6938 DEFB $00,$18,$30,$00,$00,$00,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $6940 DEFB $06,$0C,$08,$08,$08,$0C,$06,$00 ; #UDG(#PC,attr=7,scale=2)
 $6948 DEFB $60,$30,$10,$10,$10,$30,$60,$00 ; #UDG(#PC,attr=7,scale=2)
 $6950 DEFB $00,$00,$14,$08,$3E,$08,$14,$00 ; #UDG(#PC,attr=7,scale=2)
 $6958 DEFB $00,$00,$08,$08,$3E,$08,$08,$00 ; #UDG(#PC,attr=7,scale=2)
 $6960 DEFB $00,$00,$00,$00,$00,$0C,$18,$30 ; #UDG(#PC,attr=7,scale=2)
 $6968 DEFB $00,$00,$00,$7E,$7E,$00,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $6970 DEFB $00,$00,$00,$00,$30,$70,$70,$00 ; #UDG(#PC,attr=7,scale=2)
 $6978 DEFB $02,$06,$0C,$18,$30,$60,$40,$00 ; #UDG(#PC,attr=7,scale=2)
 $6980 DEFB $00,$7E,$62,$62,$62,$62,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6988 DEFB $00,$18,$38,$18,$18,$18,$3C,$00 ; #UDG(#PC,attr=7,scale=2)
 $6990 DEFB $00,$38,$4C,$4C,$18,$30,$7C,$00 ; #UDG(#PC,attr=7,scale=2)
 $6998 DEFB $00,$3C,$62,$0C,$06,$66,$3C,$00 ; #UDG(#PC,attr=7,scale=2)
 $69A0 DEFB $00,$30,$30,$30,$30,$34,$3E,$04 ; #UDG(#PC,attr=7,scale=2)
 $69A8 DEFB $00,$7E,$60,$7E,$06,$66,$3C,$00 ; #UDG(#PC,attr=7,scale=2)
 $69B0 DEFB $00,$30,$60,$7C,$66,$66,$3C,$00 ; #UDG(#PC,attr=7,scale=2)
 $69B8 DEFB $00,$7E,$46,$0C,$18,$30,$60,$00 ; #UDG(#PC,attr=7,scale=2)
 $69C0 DEFB $00,$3C,$66,$3C,$66,$66,$3C,$00 ; #UDG(#PC,attr=7,scale=2)
 $69C8 DEFB $00,$3C,$66,$66,$3E,$06,$3C,$00 ; #UDG(#PC,attr=7,scale=2)
 $69D0 DEFB $00,$00,$08,$18,$00,$08,$18,$00 ; #UDG(#PC,attr=7,scale=2)
 $69D8 DEFB $00,$00,$04,$0C,$00,$0C,$18,$30 ; #UDG(#PC,attr=7,scale=2)
 $69E0 DEFB $00,$00,$04,$08,$10,$08,$04,$00 ; #UDG(#PC,attr=7,scale=2)
 $69E8 DEFB $00,$00,$00,$3E,$00,$3E,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $69F0 DEFB $00,$00,$10,$08,$04,$08,$10,$00 ; #UDG(#PC,attr=7,scale=2)
 $69F8 DEFB $00,$3C,$42,$04,$08,$00,$08,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A00 DEFB $00,$3C,$4A,$56,$5E,$40,$3C,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A08 DEFB $00,$7E,$46,$46,$7E,$46,$46,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A10 DEFB $00,$7C,$62,$7C,$62,$62,$7C,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A18 DEFB $00,$7E,$66,$60,$60,$66,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A20 DEFB $00,$7C,$46,$46,$46,$46,$7C,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A28 DEFB $00,$7E,$60,$7C,$60,$60,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A30 DEFB $00,$7E,$60,$7C,$60,$60,$60,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A38 DEFB $00,$3E,$62,$60,$66,$66,$3E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A40 DEFB $00,$62,$62,$7E,$62,$62,$62,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A48 DEFB $00,$18,$18,$18,$18,$18,$18,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A50 DEFB $00,$0C,$0C,$0C,$0C,$4C,$38,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A58 DEFB $00,$66,$64,$68,$7E,$46,$66,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A60 DEFB $00,$60,$60,$60,$60,$60,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A68 DEFB $00,$7E,$56,$56,$56,$56,$56,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A70 DEFB $00,$7E,$46,$46,$46,$46,$46,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A78 DEFB $00,$7E,$62,$62,$62,$62,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A80 DEFB $00,$7E,$62,$62,$7E,$60,$60,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A88 DEFB $00,$7C,$64,$64,$64,$64,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A90 DEFB $00,$7C,$62,$64,$7C,$46,$46,$00 ; #UDG(#PC,attr=7,scale=2)
 $6A98 DEFB $00,$7E,$60,$7E,$06,$06,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6AA0 DEFB $00,$7E,$18,$18,$18,$18,$18,$00 ; #UDG(#PC,attr=7,scale=2)
 $6AA8 DEFB $00,$62,$62,$62,$62,$62,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6AB0 DEFB $00,$62,$62,$62,$62,$34,$18,$00 ; #UDG(#PC,attr=7,scale=2)
 $6AB8 DEFB $00,$6A,$6A,$6A,$6A,$6A,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6AC0 DEFB $00,$62,$62,$34,$4E,$46,$46,$00 ; #UDG(#PC,attr=7,scale=2)
 $6AC8 DEFB $00,$62,$62,$7E,$18,$18,$18,$00 ; #UDG(#PC,attr=7,scale=2)
 $6AD0 DEFB $00,$7E,$06,$1C,$38,$60,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6AD8 DEFB $00,$0E,$08,$08,$08,$08,$0E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6AE0 DEFB $00,$00,$40,$20,$10,$08,$04,$00 ; #UDG(#PC,attr=7,scale=2)
 $6AE8 DEFB $00,$70,$10,$10,$10,$10,$70,$00 ; #UDG(#PC,attr=7,scale=2)
 $6AF0 DEFB $00,$08,$1C,$2A,$08,$08,$08,$08 ; #UDG(#PC,attr=7,scale=2)
 $6AF8 DEFB $00,$00,$00,$00,$00,$00,$00,$FF ; #UDG(#PC,attr=7,scale=2)
 $6B00 DEFB $0C,$12,$10,$38,$10,$10,$3E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B08 DEFB $00,$00,$3C,$06,$7E,$46,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B10 DEFB $00,$60,$60,$7E,$62,$62,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B18 DEFB $00,$00,$7E,$62,$60,$62,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B20 DEFB $00,$06,$06,$7E,$46,$46,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B28 DEFB $00,$00,$7E,$46,$7E,$60,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B30 DEFB $00,$1E,$30,$3C,$30,$30,$30,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B38 DEFB $00,$00,$7E,$46,$46,$3E,$06,$3E ; #UDG(#PC,attr=7,scale=2)
 $6B40 DEFB $00,$60,$60,$7C,$66,$66,$66,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B48 DEFB $00,$18,$00,$38,$18,$18,$3C,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B50 DEFB $00,$0C,$00,$0C,$0C,$0C,$4C,$38 ; #UDG(#PC,attr=7,scale=2)
 $6B58 DEFB $00,$20,$2C,$38,$38,$2C,$26,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B60 DEFB $00,$18,$18,$18,$18,$18,$0E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B68 DEFB $00,$00,$6C,$56,$56,$56,$46,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B70 DEFB $00,$00,$7C,$46,$46,$46,$46,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B78 DEFB $00,$00,$3C,$46,$46,$46,$3C,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B80 DEFB $00,$00,$7C,$66,$66,$7C,$60,$60 ; #UDG(#PC,attr=7,scale=2)
 $6B88 DEFB $00,$00,$3E,$46,$46,$3E,$06,$06 ; #UDG(#PC,attr=7,scale=2)
 $6B90 DEFB $00,$00,$3C,$62,$60,$60,$60,$00 ; #UDG(#PC,attr=7,scale=2)
 $6B98 DEFB $00,$00,$3C,$60,$3C,$06,$3C,$00 ; #UDG(#PC,attr=7,scale=2)
 $6BA0 DEFB $00,$30,$78,$30,$30,$30,$1C,$00 ; #UDG(#PC,attr=7,scale=2)
 $6BA8 DEFB $00,$00,$46,$46,$46,$46,$3C,$00 ; #UDG(#PC,attr=7,scale=2)
 $6BB0 DEFB $00,$00,$46,$46,$2C,$3C,$18,$00 ; #UDG(#PC,attr=7,scale=2)
 $6BB8 DEFB $00,$00,$46,$56,$56,$56,$2C,$00 ; #UDG(#PC,attr=7,scale=2)
 $6BC0 DEFB $00,$00,$46,$2C,$18,$2C,$46,$00 ; #UDG(#PC,attr=7,scale=2)
 $6BC8 DEFB $00,$00,$46,$46,$46,$3E,$06,$3C ; #UDG(#PC,attr=7,scale=2)
 $6BD0 DEFB $00,$00,$7E,$0C,$18,$30,$7E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6BD8 DEFB $00,$0E,$08,$30,$08,$08,$0E,$00 ; #UDG(#PC,attr=7,scale=2)
 $6BE0 DEFB $00,$08,$08,$08,$08,$2A,$1C,$08 ; #UDG(#PC,attr=7,scale=2)
 $6BE8 DEFB $00,$70,$10,$0C,$10,$10,$70,$00 ; #UDG(#PC,attr=7,scale=2)
 $6BF0 DEFB $00,$14,$28,$00,$00,$00,$00,$00 ; #UDG(#PC,attr=7,scale=2)
 $6BF8 DEFB $FF,$81,$81,$81,$81,$81,$81,$FF ; #UDG(#PC,attr=7,scale=2)

; Main Entry Point
;
; Main entry point of the program.
@label=Main_Entry
c$6C00 DI              ; disable interrupts                           
 $6C01 LD HL,$761D     ; #REGhl points to #R$761D address
 $6C04 LD (IY+$67),$C3 ; set 'JP' opcode at #R$5CA1                   
 $6C08 LD (IY+$68),L   ; set low byte of #R$761D address at #R$5CA1+1
 $6C0B LD (IY+$69),H   ; set high byte of #R$761D address at #R$5CA1+2
 $6C0E LD A,$2E        ; set high byte of interrupt vector address    
 $6C10 LD I,A          ; set interrupt vector address                 
 $6C12 IM 2            ; set interrupt mode 2                         
 $6C14 LD SP,$6000     ; move stack                                   
 $6C17 XOR A           ; #REGa=0                                      
 $6C18 OUT ($FE),A     ; set border color (BLACK)
 $6C1A CALL $7974      ; show main menu and wait for an option
; This routine continues into #R$6C1D.

; Start New Game
;
; The routine at #R$6C00 continues here.
; .
; Start a new game.
@label=*Main_Start
c$6C1D CALL $7709      ; fill in black the whole screen area and attributes area
 $6C20 CALL $7716      ; draw the two rows of letters on the screen (a..g)      
 $6C23 CALL $7742      ; draw the two columns of numbers on the screen (1..7)   
 $6C26 CALL $7781      ; draw the screen frame                                  
 $6C29 CALL $77D9      ; draw the fixed tokens on the screen                    
 $6C2C CALL $77F8      ; draw the timer quotes (' ") on the screen              
 $6C2F CALL $783B      ; apply color to statics items of the screen             
 $6C32 EI              ; enable interrupts
; This entry point is used by the routine at #R$6CB9.
@label=Main_New_Level
*$6C33 LD A,$04        ; maximum level
 $6C35 LD HL,$619D     ; #REGhl points to #R$619D address
 $6C38 CP (HL)         ; level 4 achieved?                          
 $6C39 JR NZ,$6C40     ; no, increment game level                   
 $6C3B CALL $7875      ; show last level screen and input game level
 $6C3E JR $6C1D        ; start a new game
@label=Main_Increment_Level
*$6C40 INC (HL)        ; increment game level                         
 $6C41 CALL $7918      ; set up frame color depending on current level
 $6C44 CALL $7907      ; clear all three-in-a-row marks               
 $6C47 XOR A           ; #REGa=0
 $6C48 LD ($620F),A    ; initialize #R$620F
; This routine continues into #R$6C4B.

; Start New Match
;
; Used by the routine at #R$6CB9.
; .
; The routine at #R$6C1D continues here.
; .
; Start a new match.
; .
; - set up timers and clear last messages
@label=*Main_Start_Match
c$6C4B CALL $76B2      ; reset timers
 $6C4E CALL $769D      ; display timers            
 $6C51 CALL $6F0E      ; clear last alert          
 $6C54 LD A,$02        ; set token color (RED)
 $6C56 LD ($619E),A    ; save at #R$619E
 $6C59 CALL $6F35      ; clear red player last move
; - swap players' colors
 $6C5C LD A,($619F)    ; get current #R$619F
 $6C5F XOR $07         ; swap color                         
 $6C61 LD ($619F),A    ; save swapped #R$619F
 $6C64 CALL $6EF1      ; print "Player" and "Speccy" strings
; - initialize positions and draw empty board
 $6C67 LD HL,$7D00     ; #REGhl points to #R$7D00 address
 $6C6A LD DE,$7D01     ; #REGde points to #R$7D00+1 address
 $6C6D LD (HL),$00     ; set first position as empty                          
 $6C6F LD BC,$01FF     ; length of cyan + red positions areas (-1 already set)
 $6C72 LDIR            ; fill the rest of positions as empty
 $6C74 CALL $6DA1      ; draw an empty hexagons board
; - initialize draw token delay, move number and token color
 $6C77 LD A,$0A        ; {set delay duration at #R$6DCF+1
 $6C79 LD ($6DD0),A    ; }
 $6C7C LD A,$01        ; {initialize #R$619B
 $6C7E LD ($619B),A    ; }
 $6C81 LD A,$05        ; first player token color (CYAN)
; This routine continues into #R$6C83.

; Match Loop
;
; The routine at #R$6C4B continues here.
; .
; Processes the players' moves until one of them wins the match.
; .
; - check player turn
@label=*Main_Match_Loop
c$6C83 LD ($619E),A    ; save #R$619E
 $6C86 LD HL,$619F     ; #REGhl points to #R$619F address
 $6C89 CP (HL)         ; is player color = current token color?
 $6C8A JR Z,$6C91      ; yes, process player move              
 $6C8C CALL $6CEC      ; get the speccy move                   
 $6C8F JR $6C94        ; update board position
@label=Main_Player_Move
*$6C91 CALL $6D36      ; get a legal (empty position) player move
; - update positions with player/speccy move
@label=Main_Update_Board
*$6C94 CALL $70ED      ; get player/speccy side             
 $6C97 CALL $70F7      ; put token on cyan and red positions
; - draw token on the board
 $6C9A XOR A           ; #REGa=0
 $6C9B LD ($62E9),A    ; set #R$62E9 (stop timers)
 $6C9E CALL $6DBC      ; animate hexagon sprite on the screen      
 $6CA1 LD IX,$64E7     ; #REGix points to #R$64E7 address
 $6CA5 CALL $76C7      ; play sound effect
; - check for a winner
 $6CA8 CALL $75A0      ; check current player victory path
 $6CAB INC A           ; is there a victory path?         
 $6CAC JR NZ,$6CB9     ; yes, match ends                  
 $6CAE LD HL,$619B     ; HL points to #R$619B address
 $6CB1 INC (HL)        ; increment move number
; - swap players' token color
 $6CB2 LD A,($619E)    ; get #R$619E
 $6CB5 XOR $07         ; swap token color       
 $6CB7 JR $6C83        ; repeat match loop

; Match End
;
; Used by the routine at #R$6C83.
; .
; Current player wins the match.
;
; I:A Start position of the victory path
@label=*Main_Match_End
c$6CB9 LD B,A          ; set start position of victory path in #REGb
 $6CBA LD A,$04        ; {set delay duration at #R$6DCF+1
 $6CBC LD ($6DD0),A    ; }
 $6CBF CALL $75D5      ; animate and highlight the winner path      
 $6CC2 LD DE,$623B     ; #REGde points to #R$623B address
 $6CC5 CALL $6F15      ; print "WINS"
 $6CC8 LD A,($619E)    ; get #R$619E
 $6CCB LD HL,$619F     ; check #R$619F
 $6CCE CP (HL)         ; is player color = current token color?     
 $6CCF LD HL,$620F     ; #REGhl points to #R$620F
 $6CD2 JR Z,$6CD8      ; yes, go to increment three-in-a-row counter
 $6CD4 DEC (HL)        ; decrement three-in-a-row counter           
 $6CD5 JP P,$6CD9      ; if not negative (-1), show marks
@label=Main_ThreeRow_Increment
*$6CD8 INC (HL)        ; increment three-in-a-row counter
@label=Main_ThreeRow_Show
*$6CD9 CALL $78EB      ; show three-in-a-row marks
 $6CDC LD A,$FF        ; set delay duration       
 $6CDE CALL $6D92      ; execute delay            
 $6CE1 LD A,($620F)    ; check #R$620F
 $6CE4 CP $03          ; is it 3?                 
 $6CE6 JP Z,$6C33      ; yes, start a new level   
 $6CE9 JP $6C4B        ; start a new match

; Get Speccy Move
;
; Used by the routine at #R$6C83.
; .
; Get the speccy move from BRAINIAC or #R$62CE.
;
; I:A Current token color
; O:BC Hexagon board indexes (#REGb=column, #REGc=row)
;   HL #R$7D00 move address
@label=*Main_GetSpeccy_Move
c$6CEC AND $03         ; calculate speccy's timer flag based on current token color
 $6CEE LD ($62E9),A    ; (re)start #R$62E9
 $6CF1 CALL $6F2E      ; print "WAIT" message                                      
 $6CF4 LD A,($619B)    ; get #R$619B
 $6CF7 DEC A           ; is it cyan first move?                                    
 $6CF8 JR Z,$6D24      ; yes, get move from opening book                           
 $6CFA LD IX,$7F00     ; #REGix points to #R$7F00 address
 $6CFE LD A,($619D)    ; get #R$619D
 $6D01 LD ($619A),A    ; save it at #R$619A
 $6D04 CALL $70ED      ; #REGa=speccy side
 $6D07 CALL $6F7F      ; get speccy best move                                      
 $6D0A LD L,E          ; set node index in #REGl
@label=Main_GetSpeccy_Pos
*$6D0B LD H,$7D        ; #REGhl points to #R$7D00 move address
 $6D0D PUSH HL         ; store position move address
 $6D0E CALL $6D81      ; convert board position to indexes       
 $6D11 LD A,B          ; get 1..7 column                         
 $6D12 ADD A,$60       ; adjust to charset ('a'..'g')            
 $6D14 LD ($6216),A    ; put it at #R$6216        
 $6D17 LD A,C          ; get 1..7 row                            
 $6D18 ADD A,$30       ; adjust to charset ('1'..'7')            
 $6D1A LD ($6219),A    ; put it at #R$6216
 $6D1D PUSH BC         ; store hexagon board indexes             
 $6D1E CALL $6F3C      ; print Speccy move                       
 $6D21 POP BC          ; restore hexagon board indexes           
 $6D22 POP HL          ; restore position move address
 $6D23 RET             ;
@label=Main_GetSpeccy_Book
*$6D24 LD A,R          ; get a pseudo-random number (0..127) 
 $6D26 AND $1F         ; number is in range (0..31)         
 $6D28 CP $1B          ; is it >= 27?                       
 $6D2A JR NC,$6D24     ; yes, repeat until range is (0..26) 
 $6D2C LD HL,$62CE     ; #REGhl points to #R$62CE address
 $6D2F LD D,$00        ; {set index in #REGde
 $6D31 LD E,A          ; }
 $6D32 ADD HL,DE       ; #REGhl points to move index address
 $6D33 LD L,(HL)       ; get move from opening book     
 $6D34 JR $6D0B        ; get speccy move positions

; Get Player Move
;
; Used by the routine at #R$6C83.
; .
; Get a legal (empty hexagon) move from player.
;
; I:A Current token color
; O:BC Hexagon board indexes (#REGb=column, #REGc=row)
;   HL #R$7D00 move address
@label=*Main_GetPlayer_Move
c$6D36 AND $03         ; calculate player's timer flag based on current token color
 $6D38 LD ($62E9),A    ; (re)start #R$62E9
@label=Main_GetPlayer_Input
*$6D3B CALL $6F35      ; clear player last move                    
 $6D3E CALL $6E2B      ; wait for input player move                
 $6D41 CALL $6F3C      ; print player move                         
 $6D44 LD A,($6216)    ; get column ('a'..'g') at #R$6216
 $6D47 SUB $60         ; convert to number (1..7)                  
 $6D49 LD B,A          ; set column index in #REGb
 $6D4A LD A,($6219)    ; get row ('1'..'7') at #R$6216+3
 $6D4D SUB $30         ; convert to number (1..7)                  
 $6D4F LD C,A          ; set row index in #REGc
 $6D50 LD DE,$624E     ; #REGde points to #R$624E address
 $6D53 CALL $6D74      ; search board position in board coordinates table
 $6D56 LD L,(HL)       ; set board position of player move         
 $6D57 LD H,$7D        ; #REGhl points to #R$7D00 move address
 $6D59 LD A,$00        ; check position                            
 $6D5B CP (HL)         ; is position empty?                        
 $6D5C RET Z           ; yes, return to #R$6C94
; Illegal player move (position not empty).
 $6D5D LD DE,$622F     ; #REGde points to #R$622F address
 $6D60 CALL $6F15      ; print string                               
 $6D63 LD IX,$64F7     ; #REGix points #R$64F7 address
 $6D67 CALL $76C7      ; play sound effect
 $6D6A LD A,$50        ; set delay counter                          
 $6D6C CALL $6D92      ; execute delay                              
 $6D6F CALL $6F0E      ; clear alert message                        
 $6D72 JR $6D3B        ; repeat player input until move is legal

; Search Element in Table
;
; Used by the routines at #R$6DD7 and #R$6D36.
; .
; Search an element in a 8x8 bytes table.
;
; I:BC Element indexes (#REGb=column, #REGc=row)
;   DE Table address in which to search for the element
; O:DE Address of first element in the #REGc row of the table
;   HL Address of the element in the #REGbc indexes of the table
;
; First, get the #REGc row in table.
@label=*Main_Search_Table
c$6D74 LD H,$00        ; {set row index in #REGhl
 $6D76 LD L,C          ; }
 $6D77 ADD HL,HL       ; {a row is 8 bytes long
 $6D78 ADD HL,HL       ;
 $6D79 ADD HL,HL       ; }
 $6D7A ADD HL,DE       ; #REGhl points to the address of #REGc row
 $6D7B EX DE,HL        ; save it in #REGde
; Now, go for to the #REGb column.
 $6D7C LD H,$00        ; {set column index in #REGhl
 $6D7E LD L,B          ; }
 $6D7F ADD HL,DE       ; #REGhl points to the address of #REGbc indexes
 $6D80 RET             ;
 
; Convert Board Position to Indexes
;
; Used by the routines at #R$6CEC and #R$75D5.
; .
; Convert a board position into a board indexes.
;
; I:L Board position
; O:BC Board indexes (#REGb=column, #REGc=row)
@label=*Main_Board2Indexes
c$6D81 LD A,L          ; set board position in #REGa to compare later
 $6D82 LD HL,$628E     ; #REGhl points to last #R$624E address (+1)
 $6D85 LD C,$07        ; 7 rows
@label=Main_Board2Indexes_Row
*$6D87 LD B,$07        ; 7 columns
@label=Main_Board2Indexes_Col
*$6D89 DEC HL          ; move #REGhl to next board position address
 $6D8A CP (HL)         ; is #REGa the position?
 $6D8B RET Z           ; yes, return board indexes             
 $6D8C DJNZ $6D89      ; repeat for each column                
 $6D8E DEC HL          ; skip borders                          
 $6D8F DEC C           ; decrement row                         
 $6D90 JR $6D87        ; loop until find position

; Execute a Delay
;
; Used by the routines at #R$6D36, #R$6DBC and #R$6CB9.
;
; I:A Delay counter
@label=*Main_Delay
c$6D92 PUSH BC         ; store #REGbc register
@label=Main_Delay_Loop
*$6D93 LD C,$0A        ; set outer loop counter
@label=Main_Delay_Loop1
*$6D95 LD B,$00        ; set inner loop counter (256)
@label=Main_Delay_Loop2
*$6D97 DJNZ $6D97      ; repeat until #REGb=0
 $6D99 DEC C           ; decrement outer loop counter
 $6D9A JR NZ,$6D95     ; repeat until #REGc=0
 $6D9C DEC A           ; decrement delay counter     
 $6D9D JR NZ,$6D93     ; repeat until #REGa=0
 $6D9F POP BC          ; restore #REGbc register
 $6DA0 RET             ;

; Draw Empty Board
;
; Used by the routines at #R$79F7, #R$7AA3 and #R$6C4B.
; .
; Draw an empty 7x7 hexagons board on the screen
@label=*Draw_Board
c$6DA1 LD A,$07        ; set empty hexagon color (WHITE)
 $6DA3 LD ($619E),A    ; store at #R$619E
 $6DA6 LD C,$07        ; 7 rows
@label=Draw_Board_Row
*$6DA8 LD B,$07        ; 7 columns
@label=Draw_Board_Column
*$6DAA CALL $6DD7      ; get hexagon screen address
 $6DAD CALL $6E0F      ; apply color to hexagon area
 $6DB0 LD DE,$657E     ; #REGde points to #R$657E address
 $6DB3 CALL $6DE1      ; draw an empty hexagon at screen address
 $6DB6 DJNZ $6DAA      ; repeat for each column                 
 $6DB8 DEC C           ; decrement row                          
 $6DB9 JR NZ,$6DA8     ; repeat for each row
 $6DBB RET             ;

; Animate Hexagon Sprite
;
; Used by the routines at #R$6C83 and #R$75D5.
; .
; Animate an hexagon sprite on the screen.
;
; I:BC Hexagon board indexes (#REGb=column, #REGc=row)
@label=*Draw_Token
c$6DBC CALL $6DD7      ; get hexagon screen address                              
 $6DBF LD BC,$0604     ; #REGb=number of sprites, #REGc=sprite number to change color
 $6DC2 LD DE,$659E     ; #REGde points to #R$659E address
@label=Draw_Token_Loop
*$6DC5 PUSH HL         ; store hexagon screen address    
 $6DC6 CALL $6DE1      ; draw hexagon sprite             
 $6DC9 POP HL          ; restore hexagon screen address  
 $6DCA LD A,B          ; check loop counter              
 $6DCB CP C            ; is it 4?                        
 $6DCC CALL Z,$6E0F    ; yes, apply color to hexagon area
@label=Draw_Token_Delay
; The value of #REGa is initialized by the routine at #R$6C4B and updated by the routines at #R$6CB9.
 $6DCF LD A,$00        ; set delay duration
 $6DD1 CALL $6D92      ; execute delay                 
 $6DD4 DJNZ $6DC5      ; repeat for each hexagon sprite
 $6DD6 RET             ;

; Get Hexagon Screen Address
;
; Used by the routines at #R$6DA1 and #R$6DBC.
; .
; Get the screen address of an hexagon on board.
;
; I:BC Hexagon board indexes (#REGb=column, #REGc=row)
; O:HL Hexagon screen address
@label=*Draw_GetHEX_Screen
c$6DD7 LD DE,$6198     ; #REGde points to #R$61A0-8 address (adjusted for index 0)
 $6DDA CALL $6D74      ; search the screen address of the hexagon in table      
 $6DDD LD L,(HL)       ; set the low byte of the screen address in #REGl
 $6DDE LD A,(DE)       ; {set the high byte of the screen address in #REGh
 $6DDF LD H,A          ; }
 $6DE0 RET             ;

; Draw Hexagon Sprite
;
; Used by the routines at #R$7C73, #R$6DA1, #R$77D9 and #R$6DBC.
; .
; Draw an hexagon sprite on the screen.
;
; I:DE Hexagon sprite address
;   HL Hexagon screen address
; O:DE Next hexagon sprite address
@label=*Draw_Sprite_Hexagon
c$6DE1 LD IXl,$10      ; hexagon sprite height in bytes (loop counter)
@label=Draw_Sprite_HexLoop
*$6DE4 LD A,(DE)       ; get sprite byte                    
 $6DE5 LD (HL),A       ; put sprite byte on screen          
 $6DE6 INC DE          ; move #REGde to next sprite byte address
 $6DE7 INC L           ; move #REGhl to next screen column
 $6DE8 LD A,(DE)       ; get sprite byte
 $6DE9 LD (HL),A       ; put sprite byte on screen
 $6DEA INC DE          ; move #REGde to next sprite byte
 $6DEB DEC L           ; move #REGhl to previous screen column
 $6DEC CALL $6E00      ; move #REGhl down one pixel-line
 $6DEF DEC IXl         ; decrement sprite height            
 $6DF1 JR NZ,$6DE4     ; repeat for each byte in sprite
 $6DF3 RET             ;

; Draw Board Letter/Number
;
; Used by the routines at #R$7716 and #R$7742.
; .
; Draw a letter/number sprite on the screen.
;
; I:DE Letter/number sprite address
;   HL Letter/number screen address
; O:DE Next letter/number sprite address
@label=*Draw_Sprite_LetterNum
c$6DF4 LD C,$0A        ; letter/number sprite height in bytes (loop counter)
@label=Draw_Sprite_Loop
*$6DF6 LD A,(DE)       ; get sprite byte                    
 $6DF7 LD (HL),A       ; put sprite byte on screen          
 $6DF8 INC DE          ; move #REGde to next sprite byte address
 $6DF9 CALL $6E00      ; move #REGhl down one pixel-line
 $6DFC DEC C           ; decrement sprite height            
 $6DFD JR NZ,$6DF6     ; repeat for each byte in sprite
 $6DFF RET             ;

; Move Down one Pixel-Line
;
; Used by the routines at #R$6DE1, #R$6DF4 and #R$77C6.
; .
; Move #REGhl down one pixel-line.
; .
; The screen address of a pixel-line is encoded as follows:
; .
; #TABLE(default,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre)
; { =t | =h,c8 H | =h,c8 L }
; { =h Bit | 
; =h #HTML(&nbsp;&nbsp;7&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;6&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;5&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;4&nbsp;&nbsp;) |
; =h #HTML(&nbsp;&nbsp;3&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;2&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;1&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;0&nbsp;&nbsp;) |
; =h #HTML(&nbsp;&nbsp;7&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;6&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;5&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;4&nbsp;&nbsp;) |
; =h #HTML(&nbsp;&nbsp;3&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;2&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;1&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;0&nbsp;&nbsp;) }
; { =h Value | =h 0 | =h 1 | =h 0 | Y7 | Y6 | Y2 | Y1 | Y0 | Y5 | Y4 | Y3 | X4 | X3 | X2 | X1 | X0 }
; TABLE#
; .
; Where:
; .
; #LIST
; { Y = Pixel position: Y7, Y6, Y5, Y4, Y3, Y2, Y1, Y0 (0-191) }
; { X = Byte  position: 0, 0, 0, X4, X3, X2, X1, X0 (0-31) }
; LIST#
;
; I:HL Pixel-line address
; O:HL Next (down) pixel-line address
@label=*Draw_Down_PixelLine
c$6E00 INC H           ; move #REGhl down one pixel-line
 $6E01 LD A,H          ; get high byte of pixel-line address
 $6E02 AND $07         ; is pixel-line address inside a character line?
 $6E04 RET NZ          ; yes, return
 $6E05 LD A,L          ; get low byte of pixel-line address (at this point Y6 = 1)
 $6E06 ADD A,$20       ; add size of char line (add extra bit into Y3-Y5)
 $6E08 LD L,A          ; move #REGhl down one character line
 $6E09 RET C           ; a third was crossed? yes, return
 $6E0A LD A,H          ; get high byte of pixel-line address
 $6E0B SUB $08         ; clean up the bit from Y6
 $6E0D LD H,A          ; #REGhl points to next (down) pixel-line address
 $6E0E RET             ;

; Apply Color to Hexagon/Token
;
; Used by the routines at #R$7C73, #R$6DA1, #R$77D9 and #R$6DBC.
; .
; Apply color to the attributes area of an hexagon/token sprite.
; .
; This routine converts a screen address into an attribute address:
; .
; #TABLE(default,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre)
; { =t | =h,c8 H | =h,c8 L }
; { =h Bit |
; =h #HTML(&nbsp;&nbsp;7&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;6&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;5&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;4&nbsp;&nbsp;) |
; =h #HTML(&nbsp;&nbsp;3&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;2&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;1&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;0&nbsp;&nbsp;) |
; =h #HTML(&nbsp;&nbsp;7&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;6&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;5&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;4&nbsp;&nbsp;) |
; =h #HTML(&nbsp;&nbsp;3&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;2&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;1&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;0&nbsp;&nbsp;) }
; { =h Value | =h 0 | =h 1 | =h 0 | Y7 | Y6 | Y2 | Y1 | Y0 | Y5 | Y4 | Y3 | X4 | X3 | X2 | X1 | X0 }
; TABLE#
; .
; #TABLE(default,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre,centre)
; { =t | =h,c8 IXH | =h,c8 IXL }
; { =h Bit |
; =h #HTML(&nbsp;&nbsp;7&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;6&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;5&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;4&nbsp;&nbsp;) |
; =h #HTML(&nbsp;&nbsp;3&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;2&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;1&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;0&nbsp;&nbsp;) |
; =h #HTML(&nbsp;&nbsp;7&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;6&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;5&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;4&nbsp;&nbsp;) |
; =h #HTML(&nbsp;&nbsp;3&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;2&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;1&nbsp;&nbsp;) | =h #HTML(&nbsp;&nbsp;0&nbsp;&nbsp;) }
; { =h Value | =h 0 | =h 1 | =h 0 | =h 1 | =h 1 | =h 0 | Y7 | Y6 | Y5 | Y4 | Y3 | X4 | X3 | X2 | X1 | X0 }
; TABLE#
; .
; Where:
; .
; #LIST
; { Y = Pixel position: Y7, Y6, Y5, Y4, Y3, Y2, Y1, Y0 (0-191) }
; { X = Byte  position: 0, 0, 0, X4, X3, X2, X1, X0 (0-31) }
; LIST#
;
; I:HL Screen address of the hexagon/token
; O:A #R$619E
;   IX Attribute address of the hexagon/token
@label=*Draw_Hexagon_Color
c$6E0F LD A,H          ; get high byte of screen address
 $6E10 OR $87          ; mask Y0-Y2 and set bit 7 on    
 $6E12 RRA             ; {shift Y7-Y6 two positions
 $6E13 RRA             ; }
 $6E14 SRL A           ; shift Y7-Y6 to last positions and set bit 7 off    
 $6E16 LD IXh,A        ; set high byte of attribute address in #REGixh
 $6E18 LD A,L          ; (the low byte for attribute address doesn't change)
 $6E19 LD IXl,A        ; set low byte of attribute address in #REGixl
 $6E1B LD A,($619E)    ; get #R$619E
 $6E1E LD (IX+$00),A   ; {set hexagon/token color (4 bytes)
 $6E21 LD (IX+$01),A   ;
 $6E24 LD (IX+$20),A   ;
 $6E27 LD (IX+$21),A   ; }
 $6E2A RET             ;
 
; Input Player Move
;
; Used by the routine at #R$6D36.
; .
; This routine handles the keyboard input of the player's move.
; .
; - prints the input cursor for the move in his corresponding location, according to the current token color
@label=Input_Move
c$6E2B LD BC,$0200     ; #REGb=maximum of input chars, #REGc=chars counter
 $6E2E LD IX,$5A83     ; #REGix points to attribute address of red input text
 $6E32 LD HL,$5083     ; #REGhl points to screen address of red input text
 $6E35 LD A,($619E)    ; check #R$619E
 $6E38 CP $02          ; is red the current token color?
 $6E3A JR Z,$6E43      ; yes, start input
 $6E3C LD IX,$5919     ; #REGix points to attribute address of cyan input text
 $6E40 LD HL,$4819     ; #REGhl points to screen address of cyan input text
@label=Input_Start
*$6E43 LD (IX+$00),$C7 ; set attributes for cursor (FLASH+WHITE)
 $6E47 LD A,$5F        ; text input cursor ('_')
 $6E49 CALL $6F65      ; print cursor
; - start an input loop until player complete the move and press ENTER
@label=Input_Loop
*$6E4C CALL $6EC5      ; scan for a key pressed                                  
 $6E4F CP $0D          ; is it ENTER?                                            
 $6E51 JR Z,$6EB7      ; yes, perform enter pressed                              
 $6E53 CP $30          ; is it "delete"? (char '0' acts as delete, without Shift)
 $6E55 JR Z,$6E99      ; yes, perform delete char                                
 $6E57 EX AF,AF'       ; store char in #REGa'
 $6E58 LD A,C          ; check number of chars inserted                          
 $6E59 CP B            ; chars limit reached?                                    
 $6E5A JR Z,$6E4C      ; yes, repeat input loop                                  
 $6E5C OR A            ; is it the first char?                                   
 $6E5D JR NZ,$6E80     ; no, perform input of 2nd char
; - restrict first char to 'a'-'g'
 $6E5F EX AF,AF'       ; restore char                                
 $6E60 CP $61          ; is it < 'a'?                                
 $6E62 JR C,$6E4C      ; yes, repeat input loop (char is not allowed)
 $6E64 CP $68          ; is it >= 'g'?                               
 $6E66 JR NC,$6E4C     ; yes, repeat input loop (char is not allowed)
; - char is valid as column
 $6E68 LD ($6216),A    ; save char at #R$6216
 $6E6B LD (IX+$00),$47 ; restore attributes (BRIGHT+WHITE)
 $6E6F CALL $6F65      ; print key pressed                                    
 $6E72 INC C           ; increment chars counter                              
 $6E73 INC L           ; increment X position of current input screen location
 $6E74 INC IXl         ; increment X position of current input attributes location
 $6E76 LD A,$2D        ; set dash char ('-')
 $6E78 CALL $6F65      ; print key pressed                                    
 $6E7B INC L           ; increment X position of current input screen location
 $6E7C INC IXl         ; increment X position of current input attr location  
 $6E7E JR $6E43        ; get next char (do until ENTER is pressed)
@label=Input_Numbers
; - restrict second char to '1'-'7'
*$6E80 EX AF,AF'       ; restore char                                
 $6E81 CP $31          ; is it < '1'?                                
 $6E83 JR C,$6E4C      ; yes, repeat input loop (char is not allowed)
 $6E85 CP $38          ; is it >= '8'?                               
 $6E87 JR NC,$6E4C     ; yes, repeat input loop (char is not allowed)
; - char is valid as row
 $6E89 LD ($6219),A    ; save char at #R$6216+3
 $6E8C LD (IX+$00),$47 ; restore attributes (BRIGHT+WHITE)
 $6E90 CALL $6F65      ; print key pressed                                    
 $6E93 INC C           ; increment chars counter                              
 $6E94 INC L           ; increment X position of current input screen location
 $6E95 INC IXl         ; increment X position of current input attr location  
 $6E97 JR $6E43        ; get next char (do until ENTER is pressed)
; - player pressed "delete" (char '0')
@label=Input_Delete
*$6E99 LD A,C          ; get char counter                      
 $6E9A OR A            ; is it 0?                              
 $6E9B JR Z,$6E4C      ; repeat input loop (no chars to delete)
 $6E9D LD (IX+$00),$47 ; restore attributes (BRIGHT+WHITE)
 $6EA1 CP B            ; is it the first char?                 
 $6EA2 JR Z,$6EAC      ; yes, continue delete                  
 $6EA4 LD A,$20        ; empty char (' ')
 $6EA6 CALL $6F65      ; delete cursor and last char                  
 $6EA9 DEC L           ; decrement X position of input screen location
 $6EAA DEC IXl         ; decrement X position of input attr location
@label=Input_Delete_Char
*$6EAC DEC C           ; decrement char counter                              
 $6EAD LD A,$20        ; empty char (' ')
 $6EAF CALL $6F65      ; delete cursor and last char                         
 $6EB2 DEC L           ; decrement X position of player input screen location
 $6EB3 DEC IXl         ; decrement X position of player input attr location  
 $6EB5 JR $6E43        ; get next char
; - player pressed ENTER
@label=Input_Enter
*$6EB7 LD A,C          ; check char counter                         
 $6EB8 CP B            ; is it < maximum of input chars?
 $6EB9 JR C,$6E4C      ; yes, repeat input loop (move is incomplete)
 $6EBB LD (IX+$00),$47 ; restore attributes (BRIGHT+WHITE)
 $6EBF LD A,$20        ; empty char (' ')
 $6EC1 CALL $6F65      ; delete cursor
 $6EC4 RET             ;

; Keyboard Scanning
;
; Used by the routines at #R$7974, #R$7BDE, #R$79F7, #R$7AA3, #R$7B5A, #R$7875 and #R$6E2B.
; .
; Wait for a key pressed and return its ASCII code.
; .
; #TABLE(default,centre,centre,centre,centre,centre,centre)
; { =h,r2 Port | =h,c5 Bit }
; { =h 0 | =h 1 | =h 2 | =h 3 | =h 4 }
; { $FEFE | Shift | Z | X | C | V }
; { $FDFE | A | S | D | F | G }
; { $FBFE | Q | W | E | R | T }
; { $F7FE | 1 | 2 | 3 | 4 | 5 }
; { $EFFE | 0 | 9 | 8 | 7 | 6 }
; { $DFFE | P | O | I | U | Y }
; { $BFFE | Enter | L | K | J | H }
; { $7FFE | Space | #HTML(&nbsp;&nbsp;Sym&nbsp;&nbsp;) | #HTML(&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;) | #HTML(&nbsp;&nbsp;&nbsp;N&nbsp;&nbsp;&nbsp;) | #HTML(&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;) }
; TABLE#
; .
; Bits are set to 0 for any key that is pressed and 1 for any key that is not pressed.
;
; O:A ASCII code of key pressed
@label=*Input_Key_Scan
c$6EC5 PUSH BC         ; {store #REGbc and #REGhl registers
 $6EC6 PUSH HL         ; }
@label=Input_Key_Released
*$6EC7 LD BC,$FEFE     ; set keyboard port (see above)
@label=Input_Key_Released_Line
*$6ECA IN A,(C)        ; read port                                         
 $6ECC CPL             ; invert bits                                       
 $6ECD AND $1F         ; check 0 to 4 bits                                 
 $6ECF JR NZ,$6EC7     ; repeat from the beginning until no key is pressed 
 $6ED1 RLC B           ; move #REGbc to the next port
 $6ED3 JR C,$6ECA      ; repeat for each port                              
 $6ED5 LD DE,$0005     ; #REGde=number of keys in each port
@label=Input_Key_Pressed_Begin
*$6ED8 LD HL,$61D8     ; #REGhl points to #R$61D8 array
@label=Input_Key_Pressed_Line
*$6EDB IN A,(C)        ; read port
 $6EDD CPL             ; invert bits
 $6EDE AND $1F         ; check 0 to 4 bits                                 
 $6EE0 JR NZ,$6EEA     ; if any key is pressed, process it                 
 $6EE2 ADD HL,DE       ; #REGhl points to the next five keys
 $6EE3 RLC B           ; move #REGbc to the next port
 $6EE5 JR C,$6EDB      ; repeat for each port                              
 $6EE7 JR $6ED8        ; repeat from the beginning until any key is pressed
@label=Input_Key_Next
*$6EE9 INC HL          ; move #REGhl to the next character code
@label=Input_Key_Pressed
*$6EEA RRA             ; rotate bits of port readed       
 $6EEB JR NC,$6EE9     ; repeat until find the key pressed
 $6EED LD A,(HL)       ; return key pressed (ASCII) in A  
 $6EEE POP HL          ; {restore #REGhl and #REGbc registers
 $6EEF POP BC          ; }
 $6EF0 RET             ;

; Print "Player" and "Speccy"
;
; Used by the routine at #R$6C4B.
; .
; Print "Player" and "Speccy" in their corresponding screen addresses.
;
; I:A #R$619F
@label=*Print_Players
c$6EF1 LD DE,$6222     ; #REGde points to #R$6222 address
 $6EF4 LD BC,$621B     ; #REGbc points to #R$621B address  
 $6EF7 LD HL,$5002     ; #REGhl points to red string screen address
 $6EFA CP $02          ; is player color red?                  
 $6EFC JR Z,$6F04      ; yes, print players strings
 $6EFE LD DE,$621B     ; #REGde points to #R$621B address
 $6F01 LD BC,$6222     ; #REGbc points to #R$6222 address
@label=Print_Players_Strings
*$6F04 CALL $6F59      ; print "Player" or "Speccy"
 $6F07 LD D,B          ; {#REGde points to "Player" or "Speccy" string address
 $6F08 LD E,C          ; }
 $6F09 LD HL,$4098     ; #REGhl points to cyan string screen address
 $6F0C JR $6F59        ; print "Player" or "Speccy"

; Print and Clear Game Messages
;
; Clear a printed alert message below the current player input move. Used by the routine at #R$6C4B and #R$6D36.
@label=*Print_Clear_Alert
c$6F0E LD DE,$6247     ; #REGde points to #R$6247 address
 $6F11 LD C,$47        ; set (clear) alert message color (BRIGHT+WHITE)
 $6F13 JR $6F17        ; print (clear) alert string
; Print an alert message below the current player input move. Used by the routines at #R$6D36 and #R$6CB9 with #REGde pointing to the alert string address.
@label=Print_Alert
*$6F15 LD C,$C7        ; set alert message color (FLASH+WHITE)
@label=Print_Alert_XY
*$6F17 LD IX,$5AA2     ; #REGix points to red alert string attribute address
 $6F1B LD HL,$50A2     ; #REGhl points to red alert string screen address
 $6F1E LD A,($619E)    ; check current #R$619E
 $6F21 CP $02          ; is token color red?
 $6F23 JR Z,$6F56      ; yes, print alert string with color
 $6F25 LD IX,$5938     ; #REGix points to cyan alert string attribute address
 $6F29 LD HL,$4838     ; #REGhl points to cyan alert string screen address
 $6F2C JR $6F56        ; print alert string with color
; Print "WAIT" message at current player input move location. Used by the routine at #R$6CEC.
@label=Print_Wait
*$6F2E LD DE,$6236     ; #REGde points to #R$6236 address
 $6F31 LD C,$C7        ; set wait message color            
 $6F33 JR $6F41        ; print wait string
; Clear a printed player move at current player input move location. Used by the routines at #R$6C4B and #R$6D36.
@label=Print_Clear_Move
*$6F35 LD DE,$6242     ; #REGde points to #R$6242 address
 $6F38 LD C,$47        ; set (clear) move string color         
 $6F3A JR $6F41        ; print (clear) move string
; Print a formatted move at current player input move location. Used by the routines at #R$6D36 and #R$6CEC.
@label=Print_Move
*$6F3C LD DE,$6216     ; #REGde points to #R$6216 address
 $6F3F LD C,$47        ; set string color (BRIGHT+WHITE)
@label=Print_Move_XY
*$6F41 LD IX,$5A82     ; #REGix points to red move attribute address
 $6F45 LD HL,$5083     ; #REGhl points to red move screen address
 $6F48 LD A,($619E)    ; check current #R$619E
 $6F4B CP $02          ; is token color red?                     
 $6F4D JR Z,$6F56      ; yes, print move string with color       
 $6F4F LD IX,$5918     ; #REGix points to cyan move attribute address
 $6F53 LD HL,$4819     ; #REGhl points to cyan move screen address
@label=Print_String_Color
*$6F56 CALL $786B      ; apply color to string area
; These routines continue into #R$6F59.

; Print String
;
; Used by the routines at #R$7974, #R$7BDE, #R$7781, #R$79F7, #R$7AA3, #R$7B5A, #R$7875 and #R$6EF1.
; .
; The routines at #R$6F0E, #R$6F15, #R$6F2E, #R$6F35 and #R$6F3C continue here.
; .
; Print a string on the screen.
;
; I:DE String address
;   HL String screen address
@label=*Print_String
c$6F59 LD A,(DE)       ; get string character             
 $6F5A OR A            ; is it 0? (end of string)         
 $6F5B RET Z           ; yes, return                      
 $6F5C PUSH DE         ; store pointer to string address  
 $6F5D CALL $6F65      ; print character                  
 $6F60 POP DE          ; restore pointer to string address
 $6F61 INC DE          ; move #REGde to next string character
 $6F62 INC L           ; move #REGhl to next screen column
 $6F63 JR $6F59        ; repeat until end of string

; Print Char
;
; Used by the routines at #R$6F59, #R$7918, #R$7AA3, #R$7B5A and #R$6E2B.
; .
; Print a character on the screen.
;
; I:A Character to print (ASCII)
;   HL Character screen address
@label=*Print_Char
c$6F65 LD DE,$6800     ; #REGde points to #R$6900-256 address
; This entry point is used by the routine at #R$7781 with #REGa=tile index and #REGde pointing to #R$650E.
@label=Print_Tile
*$6F68 PUSH HL         ; store pointer to character/tile screen address
 $6F69 LD H,$00        ; {set character/tile index in #REGhl
 $6F6B LD L,A          ; }
 $6F6C ADD HL,HL       ; {a character/tile is 8 bytes long
 $6F6D ADD HL,HL       ;
 $6F6E ADD HL,HL       ; }
 $6F6F ADD HL,DE       ; move #REGhl to character/tile address
 $6F70 EX DE,HL        ; #REGde points to character/tile address
 $6F71 POP HL          ; restore pointer to character/tile screen address
 $6F72 PUSH BC         ; store #REGbc register
 $6F73 LD C,H          ; save high byte of character/tile screen address 
 $6F74 LD B,$08        ; number of character/tile bytes (loop counter)
@label=Print_Tile_Pixels
*$6F76 LD A,(DE)       ; get character/tile byte                           
 $6F77 LD (HL),A       ; put character/tile byte on screen                 
 $6F78 INC DE          ; move #REGde to next character/tile byte
 $6F79 INC H           ; move #REGhl down one pixel-line
 $6F7A DJNZ $6F76      ; repeat for each character/tile bytes              
 $6F7C LD H,C          ; restore high byte of character/tile screen address
 $6F7D POP BC          ; restore #REGbc register
 $6F7E RET             ;

; Brainiac Best Move
;
; Used by the routine at #R$6CEC.
; .
; Execute #HTML(<a href="https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC" target="_blank">BRAINIAC</a>) algorithm
; to determine best choice for specified player's next move, according to specified AI difficulty level. This algorithm is implemented
; as recursive Minimax with alpha-beta pruning, that alternates between tree nodes maximizing score (speccy move) and minimizing it
; (player move) depending on recursion depth.
; .
; Adapted for Hex game by Einar Saukas.
;
; I:A Speccy side: $02 (FRIEND) or $7E (ENEMY)
;   IX #R$7F00 address
; O:E Selected position (speccy move)
@label=*BRAINIAC_best_move
c$6F7F LD ($6199),A    ; save speccy side at #R$6199
 $6F82 CALL $747B      ; get board score
 $6F85 CALL $7524      ; get candidates from board potentials
 $6F88 LD A,(IX+$00)   ; #REGa is our first candidate
 $6F8B LD E,A          ; #REGe=best speccy move (initialization)
 $6F8C LD D,$00        ; initialize #REGd=alphaMax (alphaBeta pruning minimum value)
; Loop for each candidate.
@label=AI_Main_Loop
*$6F8E PUSH DE         ; store alphaMax and best speccy move
 $6F8F LD H,$7D        ; {#REGhl points to #R$7D00 candidate address
 $6F91 LD L,A          ; }
 $6F92 PUSH HL         ; store candidate position
 $6F93 LD A,($6199)    ; get #R$6199
 $6F96 CALL $70F7      ; put speccy token on both cyan and red positions
 $6F99 LD E,$FF        ; initialize #REGe=betaMin (alphaBeta pruning maximum value)
 $6F9B CALL $6FB4      ; #REGa=alphabeta_min(alphaMax, betaMin)
 $6F9E POP HL          ; restore candidate position
 $6F9F CALL $70FD      ; erase speccy token on both cyan and red positions
 $6FA2 POP DE          ; restore alphaMax and best speccy move
 $6FA3 CP D            ; check alphaMax
 $6FA4 JR C,$6FAA      ; {if (#REGa <= alphaMax) continue with next candidate
 $6FA6 JR Z,$6FAA      ; }
 $6FA8 LD D,A          ; alphaMax=#REGa
 $6FA9 LD E,L          ; best move=#REGe
@label=AI_Main_Next
*$6FAA DEC IXl         ; move #REGix to the next candidate
 $6FAC LD A,(IX+$00)   ; #REGa=next candidate
 $6FAF OR A            ; last candidate?
 $6FB0 JP NZ,$6F8E     ; no, repeat until no more candidates
 $6FB3 RET             ;

; Alphabeta Min
;
; Used by the routines at #R$6F7F and #R$7052.
; .
; Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MINIMIZING Speccy's score.
; .
; This implementation is different from conventional alpha-beta pruning because it returns the best (lowest) betaMin value
; obtained so far at this subtree depth (from previous sibling nodes), when it's even lower than the best (lowest) score at this
; tree node only. In practice that's OK, since the existence of a lower betaMin in a previous sibling node would make parent
; node discard the node's betaMin value and adopt the even lower betaMin value from a previous sibling node anyway. This
; change was useful to allow a highly optimized Assembly implementation with a more efficient register allocation. The only
; drawback was that, whenever a parent node obtains the same best score from 2 child nodes, it must always choose the child
; node evaluated first, since the other child node node may not really have the same score and could be just reproducing the
; best score from its sibling.
; .
; Original source code by #HTML(<a href="https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC" target="_blank">Einar Saukas</a>).
;
; I:D alphaMax
;   E betaMin
; O:D alphaMax
;   E "Improved" betaMin
;   A "Improved" betaMin
@label=*Alphabeta_Min
c$6FB4 PUSH DE         ; store alphaMax and betaMin
; Check if last speccy move is a winner one.
 $6FB5 CALL $747B      ; get board score
 $6FB8 OR A            ; has Speccy won?
 $6FB9 JP NZ,$6FC3     ; no, continue with candidates
 $6FBC LD A,($619A)    ; get #R$619A
 $6FBF ADD A,$C0       ; #REGa=192 + recursion depth
 $6FC1 POP DE          ; restore alphaMax and betaMin
 $6FC2 RET             ; return #REGa
; Get candidates.
@label=Alphabeta_Min_Candidates
*$6FC3 CALL $7524      ; find candidates for next move
 $6FC6 POP DE          ; restore alphaMax and betaMin
 $6FC7 LD A,(IX+$00)   ; #REGa is our first candidate
 $6FCA LD HL,$619A     ; {decrement #R$619A
 $6FCD DEC (HL)        ; }
 $6FCE JP Z,$700E      ; if (recursion depth = 0) calculate heuristic
; Loop for each candidate.
@label=Alphabeta_Min_Loop
*$6FD1 PUSH DE         ; store alphaMax and betaMin
 $6FD2 LD H,$7D        ; {#REGhl points to #R$7D00 candidate address
 $6FD4 LD L,A          ; }
 $6FD5 PUSH HL         ; store candidate position
 $6FD6 LD A,($6199)    ; get #R$6199
 $6FD9 XOR $7C         ; switch to player side
 $6FDB CALL $70F7      ; put player token on both cyan and red positions
 $6FDE CALL $7052      ; #REGa=alphabeta_max(alphaMax, betaMin)
 $6FE1 POP HL          ; restore candidate position
 $6FE2 CALL $70FD      ; erase player token on both cyan and red positions
 $6FE5 POP DE          ; restore alphaMax and betaMin
 $6FE6 CP E            ; check betaMin
 $6FE7 JR NC,$6FEF     ; if (#REGa >= betaMin) continue with next candidate
 $6FE9 CP D            ; check alphaMax
 $6FEA JR C,$6FFE      ; {if (#REGa <= alphaMax) return #REGa
 $6FEC JR Z,$6FFE      ; }
 $6FEE LD E,A          ; betaMin=#REGa
@label=Alphabeta_Min_Next
*$6FEF DEC IXl         ; move #REGix to the next candidate
 $6FF1 LD A,(IX+$00)   ; #REGa=next candidate
 $6FF4 OR A            ; last candidate?
 $6FF5 JP NZ,$6FD1     ; no, repeat until no more candidates
 $6FF8 LD A,E          ; #REGa=betaMin
 $6FF9 LD HL,$619A     ; {increment #R$619A
 $6FFC INC (HL)        ; }
 $6FFD RET             ; return betaMin
; Discard remaining candidates.
@label=Alphabeta_Min_Exit
*$6FFE LD E,A          ; betaMin=#REGa
 $6FFF XOR A           ; #REGa=0
@label=Alphabeta_Min_Skip
*$7000 DEC IXl         ; move #REGix to the next candidate
 $7002 CP (IX+$00)     ; last candidate?
 $7005 JP NZ,$7000     ; no, skip candidate
 $7008 LD A,E          ; #REGa=betaMin
 $7009 LD HL,$619A     ; {increment #R$619A
 $700C INC (HL)        ; }
 $700D RET             ; return betaMin

; Heuristic Min
;
; Used by the routine at #R$6FB4.
; .
; Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-beta pruning, when it
; requires MINIMIZING Speccy's score.
; .
; Technically "Heuristic_Min" works exactly like "Alphabeta_Min_Loop", except it directly evaluates board for each child 
; node instead of calling "Alphabeta_Max" recursively. Although it would be easier to just let it invoke "Alphabeta_Max" 
; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds faster.
; .
; Original source code by #HTML(<a href="https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC" target="_blank">Einar Saukas</a>).
;                                                                                                                        
; I:A First candidate
;   D alphaMax
;   E betaMin
; O:D alphaMax
;   E "Improved" betaMin
;   A "Improved" betaMin
;
; Loop for each candidate.
@label=*Heuristic_Min
c$700E PUSH DE         ; store alphaMax and betaMin
 $700F LD H,$7D        ; {#REGhl points to #R$7D00 candidate address
 $7011 LD L,A          ; }                                          
 $7012 PUSH HL         ; store candidate position                   
 $7013 LD A,($6199)    ; get #R$6199
 $7016 XOR $7C         ; switch to player side
 $7018 CALL $70F7      ; put player token on both cyan and red positions
 $701B CALL $747B      ; get board score
 $701E CP $FF          ; has player won?
 $7020 JP NZ,$7025     ; no, continue with candidates
 $7023 LD A,$40        ; #REGa=64
@label=Heuristic_Min_Continue
*$7025 POP HL          ; restore candidate position
 $7026 CALL $70FD      ; erase player token on both cyan and red positions
 $7029 POP DE          ; restore alphaMax and betaMin                      
 $702A CP E            ; check betaMin                                     
 $702B JR NC,$7033     ; if (#REGa >= betaMin) continue with next candidate
 $702D CP D            ; check alphaMax                                    
 $702E JR C,$7042      ; {if (#REGa <= alphaMax) return #REGa              
 $7030 JR Z,$7042      ; }                                                 
 $7032 LD E,A          ; betaMin=#REGa
@label=Heuristic_Min_Next
*$7033 DEC IXl         ; move #REGix to the next candidate  
 $7035 LD A,(IX+$00)   ; #REGa=next candidate               
 $7038 OR A            ; last candidate?                    
 $7039 JP NZ,$700E     ; no, repeat until no more candidates
 $703C LD A,E          ; #REGa=betaMin                      
 $703D LD HL,$619A     ; {increment #R$619A                 
 $7040 INC (HL)        ; }                                  
 $7041 RET             ; return betaMin
; Discard remaining candidates.
@label=Heuristic_Min_Exit
*$7042 LD E,A          ; betaMin=#REGa
 $7043 XOR A           ; #REGa=0
@label=Heuristic_Min_Skip
*$7044 DEC IXl         ; move #REGix to the next candidate
 $7046 CP (IX+$00)     ; last candidate?                  
 $7049 JP NZ,$7044     ; no, skip candidate               
 $704C LD A,E          ; #REGa=betaMin                    
 $704D LD HL,$619A     ; {increment #R$619A               
 $7050 INC (HL)        ; }                                
 $7051 RET             ; return betaMin

; Alphabeta Max
;
; Used by the routine at #R$6FB4.
; .
; Process a tree node of the Minimax search tree with alpha-beta pruning, when it requires MAXIMIZING Speccy's score.
; .
; This implementation is different from conventional alpha-beta pruning because it returns the best (highest) alphaMax value
; obtained so far at this subtree depth (from previous sibling nodes), when it's even higher than the best (highest) score at this
; tree node only. In practice that's OK, since the existence of a higher alphaMax in a previous sibling node would make parent
; node discard the node's alphaMax value and adopt the even higher alphaMax value from a previous sibling node anyway.
; This change was useful to allow a highly optimized Assembly implementation with a more efficient register allocation. The
; only drawback was that, whenever a parent node obtains the same best score from 2 child nodes, it must always choose the
; child node evaluated first, since the other child node node may not really have the same score and could be just reproducing
; the best score from its sibling.
; .
; Original source code by #HTML(<a href="https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC" target="_blank">Einar Saukas</a>).
;                                                                                                                       
; I:D alphaMax
;   E betaMin
; O:A "Improved" alphaMax
;   D "Improved" alphaMax
;   E betaMin
@label=*Alphabeta_Max
c$7052 PUSH DE         ; store alphaMax and betaMin
; Check if last player move is a winner one.
 $7053 CALL $747B      ; get board score
 $7056 CP $FF          ; has player won?
 $7058 JP NZ,$7063     ; no, continue with candidates
 $705B LD A,($619A)    ; get #R$619A
 $705E CPL             ; {#REGa=64 - recursion depth
 $705F ADD A,$41       ; }
 $7061 POP DE          ; restore alphaMax and betaMin
 $7062 RET             ; return #REGa
; Get candidates.
@label=Alphabeta_Max_Candidates
*$7063 CALL $7524      ; find candidates for next move                   
 $7066 POP DE          ; restore alphaMax and betaMin                    
 $7067 LD A,(IX+$00)   ; #REGa is our first candidate                    
 $706A LD HL,$619A     ; {decrement #R$619A                              
 $706D DEC (HL)        ; }                                               
 $706E JP Z,$70AC      ; if (recursion depth = 0) calculate heuristic
; Loop for each candidate.
@label=Alphabeta_Max_Loop
*$7071 PUSH DE         ; store alphaMax and betaMin                 
 $7072 LD H,$7D        ; {#REGhl points to #R$7D00 candidate address
 $7074 LD L,A          ; }                                          
 $7075 PUSH HL         ; store candidate position                   
 $7076 LD A,($6199)    ; get #R$6199
 $7079 CALL $70F7      ; put speccy token on both cyan and red positions
 $707C CALL $6FB4      ; #REGa=alphabeta_min(alphaMax, betaMin)
 $707F POP HL          ; restore candidate position                       
 $7080 CALL $70FD      ; erase speccy token on both cyan and red positions
 $7083 POP DE          ; restore alphaMax and betaMin
 $7084 CP D            ; check alphaMax
 $7085 JR C,$708D      ; {if (#REGa <= alphaMax) continue with next candidate
 $7087 JR Z,$708D      ; }
 $7089 CP E            ; check betaMin
 $708A JR NC,$709C     ; if (#REGa >= betaMin) return #REGa
 $708C LD D,A          ; alphaMax=#REGa
@label=Alphabeta_Max_Next
*$708D DEC IXl         ; move #REGix to the next candidate  
 $708F LD A,(IX+$00)   ; #REGa=next candidate
 $7092 OR A            ; last candidate?                    
 $7093 JP NZ,$7071     ; no, repeat until no more candidates
 $7096 LD A,D          ; #REGa=alphaMax
 $7097 LD HL,$619A     ; {increment #R$619A                 
 $709A INC (HL)        ; }                                  
 $709B RET             ; return alphaMax
; Discard remaining candidates.
@label=Alphabeta_Max_Exit
*$709C LD D,A          ; alphaMax=#REGa
 $709D XOR A           ; #REGa=0
@label=Alphabeta_Max_Skip
*$709E DEC IXl         ; move #REGix to the next candidate
 $70A0 CP (IX+$00)     ; last candidate?                  
 $70A3 JP NZ,$709E     ; no, skip candidate               
 $70A6 LD A,D          ; #REGa=alphaMax
 $70A7 LD HL,$619A     ; {increment #R$619A               
 $70AA INC (HL)        ; }                                
 $70AB RET             ; return alphaMax

; Heuristic Max
;
; Used by the routine at #R$7052.
; .
; Specialized routine to process the lowest tree node (depth zero) of the Minimax search tree with alpha-beta pruning, when it
; requires MAXIMIZING Speccy's score.
; .
; Technically "Heuristic_Max" works exactly like "Alphabeta_Max_Loop", except it directly evaluates board for each child
; node instead of calling "Alphabeta_Min" recursively. Although it would be easier to just let it invoke "Alphabeta_Min"
; again to obtain the evaluated board, this simple optimization is responsible for making BRAINIAC almost 2 seconds faster.
; .
; Original source code by #HTML(<a href="https://spectrumcomputing.co.uk/entry/31171/ZX-Spectrum/BRAINIAC" target="_blank">Einar Saukas</a>).
;
; I:A First candidate
;   D alphaMax
;   E betaMin
; O:A "Improved" alphaMax
;   D "improved" alphaMax
;   E betaMin
;
; Loop for each candidate.
@label=*Heuristic_Max
c$70AC PUSH DE         ; store alphaMax and betaMin                 
 $70AD LD H,$7D        ; {#REGhl points to #R$7D00 candidate address
 $70AF LD L,A          ; }                                          
 $70B0 PUSH HL         ; store candidate position                   
 $70B1 LD A,($6199)    ; get #R$6199
 $70B4 CALL $70F7      ; put speccy token on both cyan and red positions
 $70B7 CALL $747B      ; get board score
 $70BA OR A            ; has speccy won?
 $70BB JP NZ,$70C0     ; no, continue with candidates
 $70BE LD A,$C0        ; #REGa=192
@label=Heuristic_Max_Continue
*$70C0 POP HL          ; restore candidate position                          
 $70C1 CALL $70FD      ; erase speccy token on both cyan and red positions
 $70C4 POP DE          ; restore alphaMax and betaMin                        
 $70C5 CP D            ; check alphaMax                                      
 $70C6 JR C,$70CE      ; {if (#REGa <= alphaMax) continue with next candidate
 $70C8 JR Z,$70CE      ; }                                                   
 $70CA CP E            ; check betaMin                                       
 $70CB JR NC,$70DD     ; if (#REGa >= betaMin) return #REGa                  
 $70CD LD D,A          ; alphaMax=#REGa
@label=Heuristic_Max_Next
*$70CE DEC IXl         ; move #REGix to the next candidate  
 $70D0 LD A,(IX+$00)   ; #REGa=next candidate               
 $70D3 OR A            ; last candidate?                    
 $70D4 JP NZ,$70AC     ; no, repeat until no more candidates
 $70D7 LD A,D          ; #REGa=alphaMax                     
 $70D8 LD HL,$619A     ; {increment #R$619A                 
 $70DB INC (HL)        ; }                                  
 $70DC RET             ; return alphaMax
; Discard remaining candidates.
@label=Heuristic_Max_Exit
*$70DD LD D,A          ; alphaMax=#REGa
 $70DE XOR A           ; #REGa=0
@label=Heuristic_Max_Skip
*$70DF DEC IXl         ; move #REGix to the next candidate
 $70E1 CP (IX+$00)     ; last candidate?                  
 $70E4 JP NZ,$70DF     ; no, skip candidate               
 $70E7 LD A,D          ; #REGa=alphaMax                   
 $70E8 LD HL,$619A     ; {increment #R$619A               
 $70EB INC (HL)        ; }                                
 $70EC RET             ; return alphaMax

; Get Speccy Side
;
; Used by the routines at #R$6CEC and #R$6C83.
; .
; Return if current player is FRIEND ($02) or ENEMY ($7E) from the perspective of the cyan player.
;
; O:A $02, if current token color is cyan
;   A $7E, if current token color is red
@label=*PathFinder_Friend
c$70ED LD A,($619E)    ; get #R$619E
 $70F0 RRA             ; is current player color cyan?
 $70F1 LD A,$02        ; set FRIEND in #REGa
 $70F3 RET C           ; yes, return FRIEND           
 $70F4 XOR $7C         ; no, return ENEMY
 $70F6 RET             ;

; Put Token on Positions
;
; Used by the routines at #R$6F7F, #R$6FB4, #R$700E, #R$7052, #R$70AC and #R$6C83.
; .
; Put a token on both #R$7D00 and #R$7E00 areas.
;
; I:A $02 (FRIEND) or $7E (ENEMY)
;   HL #R$7D00 token address
@label=*PathFinder_PutToken
c$70F7 LD (HL),A       ; put token at cyan position     
 $70F8 INC H           ; move #REGhl to corresponding #R$7E00 address
 $70F9 XOR $7C         ; invert side                    
 $70FB LD (HL),A       ; put token at red position
 $70FC RET             ;

; Erase Token on Positions
;
; Used by the routines at #R$6F7F, #R$6FB4, #R$700E, #R$7052 and #R$70AC.
; .
; Erase a token on both #R$7D00 and #R$7E00 areas.
;
; I:HL #R$7D00 token address
@label=*PathFinder_EraseToken
c$70FD LD (HL),$00     ; erase token at cyan position   
 $70FF INC H           ; move #REGhl to corresponding #R$7E00 address
 $7100 LD (HL),$00     ; erase token at red position
 $7102 RET             ;
 
; Copy Positions to Boards
;
; Used by the routines at #R$7141, #R$717D, #R$71B5 and #R$71F7.
; .
; Copy from position area to its corresponding board.
;
; I:DE #R$6100 or #R$6400 address (destiny)
;   HL #R$7D00 or #R$7E00 address (origin)
@label=*PathFinder_CopyPositions
c$7103 LD BC,$0031     ; number of positions to be copied
@label=PathFinder_CopyLoop
*$7106 INC L           ; {skip borders on positions
 $7107 INC L           ; }
 $7108 INC E           ; {skip borders on board
 $7109 INC E           ; }
 $710A LDI             ; {copy a row of 7 positions
 $710C LDI             ;
 $710E LDI             ;
 $7110 LDI             ;
 $7112 LDI             ;
 $7114 LDI             ;
 $7116 LDI             ; }
 $7118 JP PE,$7106     ; repeat for each row
 $711B RET             ;

; Update Board Position
;
; Used by the routines at #R$7141, #R$717D, #R$71B5, #R$71F7, #R$7235, #R$7290, #R$72BE, #R$72E4, #R$730A, #R$7330, #R$7356, #R$737C, 
; #R$73AA, #R$73CA, #R$73E5, #R$7403, #R$7422, #R$7440 and #R$745B.
; .
; Update current board position during heuristic function evaluation.
; .
; This is an approach to Jack van Rijswijck's #HTML(<a href="https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf" target="_blank">
; thesis</a>) "two-distance" metric. The two-distance is defined as "one more than the second lowest distance of p's neighbors to q,
; with the proviso that the two-distance equals 1 if p and q are directly adjacent".
; .
; The position will be updated with a number that indicates two-distance from goal (stored in lowest 6 bits), and a flag
; that indicates a position occupied by a friendly token (stored in 6th bit). Therefore this position is updated as     
; follows, depending on current content:                                                                                
; .
; #LIST
; { $01 (SKIPPED): 1 + distance of neighbor closest to goal }
; { $02 (FRIEND): distance of neighbor closest to goal }
; { $00 (EMPTY): 1 + distance of neighbor closest to goal, if current distance is friendly, SKIPPED otherwise }
; LIST#
;                                                                                                                       
; I:F Zero flag set when (#REGhl) is FRIEND
;   C Current distance (also with a flag at 6th bit that indicates a friendly position)
;   HL Current board address (on either #R$6100 or #R$6400)
@label=*PathFinder_Update
c$711C JR Z,$7130      ; if Z flag is set, update friend distance
 $711E LD B,(HL)       ; check current position
 $711F DJNZ $713B      ; if (#REGhl) = $00, process EMPTY position
; if (#REGhl) = SKIPPED, then set (#REGhl) = #REGc+1 and insert #REGhl at queue tail
@label=PathFinder_Skipped
*$7121 LD (HL),C       ; save current distance in current position
 $7122 INC (HL)        ; increment distance of current position   
 $7123 RES 6,(HL)      ; reset friendly token flag                
 $7125 EX DE,HL        ; store current position in #REGde
; The value of #REGhl is initialized by the routines at #R$7141 and #R$71B5. Read by the routines at #R$717D, #R$71F7 and #R$7235.
@label=Queue_Tail
*$7126 LD HL,$0000     ; #REGhl points to queue tail address
 $7129 INC L           ; move queue tail down                                 
 $712A LD (HL),E       ; store position into queue tail                       
 $712B LD ($7127),HL   ; update #R$7126+1
 $712E EX DE,HL        ; restore current position
 $712F RET             ;
; if (#REGhl) = FRIEND, then set (#REGhl) = #REGc and insert HL at queue head
@label=PathFinder_Friendly
*$7130 LD (HL),C       ; save current distance in current position
 $7131 SET 6,(HL)      ; set friendly token flag                  
 $7133 LD B,L          ; save current position in #REGb
 $7134 POP DE          ; preserve RET address                     
 $7135 EX (SP),HL      ; retrieve queue head from stack
 $7136 LD (HL),B       ; push this position into queue head       
 $7137 DEC L           ; move queue head up                       
 $7138 EX (SP),HL      ; update queue head
 $7139 PUSH DE         ; restore RET address
 $713A RET
; if (#REGhl) = EMPTY, then set (#REGhl) = #REGc+1 if current distance is friendly, set (#REGhl) = SKIPPED otherwise
@label=PathFinder_EMPTY
*$713B BIT 6,C         ; is current distance friendly?                        
 $713D JR NZ,$7121     ; yes, set (#REGhl) = #REGc+1 and insert #REGhl in queue tail
 $713F INC (HL)        ; set (#REGhl) = SKIPPED to find the second lowest distance
 $7140 RET             ;

; Two-Distance Cyan Up-Down
;
; Used by the routines at #R$7482, #R$74B3, #R$7568, #R$7573 and #R$75A0.
; .
; Calculate CYAN start positions' two-distances for UP edge and then calculate the rest of CYAN positions two-distances from UP to DOWN.
;
; O:A $FF, if down edge couldn't be reached
;   A $00, if there is chain of connected cyan tokens between the two edges
;   A Last edge position visited (-1), otherwise
@label=*PathFinder_Cyan_UpDown
c$7141 LD HL,$7D07     ; #REGhl points to #R$7D00+7 address
 $7144 LD DE,$6107     ; #REGde points to #R$6100+7 addr.
 $7147 CALL $7103      ; copy from cyan positions to cyan board up-down
; This entry point is used by the routine at #R$75A0.
@label=PathFinder_Cyan_CheckPath
*$714A LD IY,$0900     ; #REGiyh=distance to edge positions, #REGiyl=last edge position visited
 $714E LD HL,$6000     ; #REGhl points to #R$6000 address
 $7151 LD ($7127),HL   ; initialize #R$7126+1
 $7154 PUSH HL         ; store cyan queue head at stack
 $7155 LD HL,$6109     ; #REGhl points to #R$6100+9 addr.
 $7158 LD C,$43        ; set start positions distance + friendly flag          
 $715A LD A,$02        ; set distance to compare with (FRIEND)
 $715C CP (HL)         ; check 1st start position distance                     
 $715D CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $7160 INC L           ; move #REGhl to next start position address
 $7161 CP (HL)         ; check 2nd start position distance
 $7162 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $7165 INC L           ; move #REGhl to next start position address
 $7166 CP (HL)         ; check 3rd start position distance
 $7167 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $716A INC L           ; move #REGhl to next start position address
 $716B CP (HL)         ; check 4th start position distance
 $716C CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $716F INC L           ; move #REGhl to next start position address
 $7170 CP (HL)         ; check 5th start position distance
 $7171 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $7174 INC L           ; move #REGhl to next start position address
 $7175 CP (HL)         ; check 6th start position distance
 $7176 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $7179 INC L           ; move #REGhl to next start position address
 $717A JP $7267        ; calculate two-distances of cyan board (up-down)

; Two-Distance Cyan Down-Up
;
; Used by the routines at #R$7482, #R$74B3, #R$7568 and #R$7573.
; .
; Calculate CYAN start positions' two-distances for DOWN edge and then calculate the rest of CYAN positions two-distances from DOWN to UP.
;
; O:A $FF, if up edge couldn't be reached
;   A $00, if there is chain of connected cyan tokens between the two edges
;   A Last edge position visited (-1), otherwise
@label=*PathFinder_Cyan_DownUp
c$717D LD HL,$7D07     ; #REGhl points to #R$7D00+7 address            
 $7180 LD DE,$614F     ; #REGde points to #R$6150-1 address
 $7183 CALL $7103      ; copy from cyan positions to cyan board down-up
 $7186 LD IY,$F700     ; #REGiyh=distance to edge positions, #REGiyl=last edge position visited
 $718A LD HL,($7127)   ; retreive #R$7126+1
 $718D PUSH HL         ; initialize cyan queue head at stack
 $718E EX DE,HL        ; {take advantage of last 'CopyPositions' execution
 $718F DEC L           ; and move #REGhl to #R$6150 last address}
 $7190 LD C,$43        ; set start positions distance + friendly flag   
 $7192 LD A,$02        ; set distance to compare with (FRIEND)          
 $7194 CP (HL)         ; check 1st start position distance              
 $7195 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance   
 $7198 DEC L           ; move #REGhl to next start position address
 $7199 CP (HL)         ; check 2nd start position distance
 $719A CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance    
 $719D DEC L           ; move #REGhl to next start position address
 $719E CP (HL)         ; check 3rd start position distance
 $719F CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance                                                   
 $71A2 DEC L           ; move #REGhl to next start position address
 $71A3 CP (HL)         ; check 4th start position distance
 $71A4 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance                                                   
 $71A7 DEC L           ; move #REGhl to next start position address
 $71A8 CP (HL)         ; check 5th start position distance
 $71A9 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance                                                   
 $71AC DEC L           ; move #REGhl to next start position address
 $71AD CP (HL)         ; check 6th start position distance
 $71AE CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance                                                   
 $71B1 DEC L           ; move #REGhl to next start position address
 $71B2 JP $7267        ; calculate two-distances of cyan board (down-up)

; Two-Distance Red Left-Right
;
; Used by the routines at #R$7482, #R$74B3, #R$7568, #R$7573 and #R$75A0.
; .
; Calculate RED start positions' two-distances for LEFT edge and then calculate the rest of RED positions two-distances from LEFT to RIGHT.
;
; O:A $FF, if right edge couldn't be reached
;   A $00, if there is chain of connected red tokens between the two edges
;   A Last edge position visited (-1), otherwise
@label=*PathFinder_Red_LeftRight
c$71B5 LD HL,$7E07     ; #REGhl points to #R$7E00+7 address
 $71B8 LD DE,$6407     ; #REGde points to #R$6400+7 addr.
 $71BB CALL $7103      ; copy from red positions to red board left-right
; This entry point is used by the routine at #R$75A0.
@label=PathFinder_Red_CheckPath
*$71BE LD IY,$0100     ; #REGiyh=distance to edge positions, #REGiyl=last edge position visited
 $71C2 LD HL,$6300     ; #REGhl points to #R$6300 address
 $71C5 LD ($7127),HL   ; initialize #R$7126+1                                                  
 $71C8 PUSH HL         ; store red queue head at stack
 $71C9 LD HL,$6409     ; #REGhl points to #R$6400+9 addr.
 $71CC LD C,$43        ; set start positions distance + friendly flag                          
 $71CE LD A,$02        ; set distance to compare with (FRIEND)                                 
 $71D0 CP (HL)         ; check 1st start position distance                                     
 $71D1 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance                          
 $71D4 LD L,$12        ; move #REGhl to next start position address                            
 $71D6 CP (HL)         ; check 2nd start position distance                                     
 $71D7 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance                                         
 $71DA LD L,$1B        ; move #REGhl to next start position address
 $71DC CP (HL)         ; check 3rd start position distance
 $71DD CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance                                                                          
 $71E0 LD L,$24        ; move #REGhl to next start position address
 $71E2 CP (HL)         ; check 4th start position distance
 $71E3 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance                                                                          
 $71E6 LD L,$2D        ; move #REGhl to next start position address
 $71E8 CP (HL)         ; check 5th start position distance
 $71E9 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance                                                                          
 $71EC LD L,$36        ; move #REGhl to next start position address
 $71EE CP (HL)         ; check 6th start position distance
 $71EF CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance                                                                          
 $71F2 LD L,$3F        ; move #REGhl to next start position address
 $71F4 JP $7267        ; calculate two-distances of red board (left-right)

;Two-Distance Red Right-Left
;
; Used by the routines at #R$7482, #R$74B3, #R$7568 and #R$7573.
; .
; Calculate RED start positions' two-distances for RIGHT edge and then calculate the rest of RED positions two-distances from RIGHT to LEFT.
;
; O:A $FF, if left edge couldn't be reached
;   A $00, if there is chain of connected red tokens between the two edges
;   A Last edge position visited (-1), otherwise
@label=*PathFinder_Red_RightLeft
c$71F7 LD HL,$7E07     ; #REGhl points to #R$7E00+7 address
 $71FA LD DE,$644F     ; #REGde points to #R$6450-1 addr.
 $71FD CALL $7103      ; copy from red positions to red board left-right
 $7200 LD IY,$FF00     ; #REGiyh=distance to edge positions, #REGiyl=last edge position visited
 $7204 LD HL,($7127)   ; retreive #R$7126+1
 $7207 PUSH HL         ; initialize red queue head at stack
 $7208 EX DE,HL        ; {take advantage of last 'CopyPositions' execution
 $7209 DEC L           ; and move #REGhl to #R$6450 last addr.}
 $720A LD C,$43        ; set start positions distance + friendly flag
 $720C LD A,$02        ; set distance to compare with (FRIEND)
 $720E CP (HL)         ; check 1st start position distance
 $720F CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $7212 LD L,$84        ; move #REGhl to next start position address
 $7214 CP (HL)         ; check 2nd start position distance
 $7215 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance   
 $7218 LD L,$7B        ; move #REGhl to next start position address
 $721A CP (HL)         ; check 3rd start position distance
 $721B CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance   
 $721E LD L,$72        ; move #REGhl to next start position address
 $7220 CP (HL)         ; check 4th start position distance
 $7221 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance   
 $7224 LD L,$69        ; move #REGhl to next start position address
 $7226 CP (HL)         ; check 5th start position distance
 $7227 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance   
 $722A LD L,$60        ; move #REGhl to next start position address
 $722C CP (HL)         ; check 6th start position distance
 $722D CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance                                                                          
 $7230 LD L,$57        ; move #REGhl to next start position address
 $7232 JP $7267        ; calculate two-distances of cyan board (right-left)

; PathFinder Two-Distance
;
; Used by the routines at #R$7141, #R$717D, #R$71B5 and #R$71F7 via #R$7267.
; .
; Calculate two-distance metric for each board position.
; .
; The algorithm is implemented running an adaptation of #HTML(<a href="https://spectrumcomputing.co.uk/entry/28178/ZX-Spectrum/PATHFINDER" target="_blank">
; PATHFINDER</a>), starting at the corresponding side of the input board.
;
; I:HL #R$6000 or #R$6300
;   IYH Distance to edge positions
;   IYL $00
; O:A $FF, if corresponding edge couldn't be reached
;   A $00, if there is chain of connected (color) tokens between the two edges
;   A Last edge position visited (-1), otherwise
@label=*Path_Finder
c$7235 INC L           ; move queue head down
 $7236 PUSH HL         ; preserve queue head address at stack
 $7237 LD L,(HL)       ; retrieve next position to be checked
 $7238 INC H           ; move #REGhl to #R$6100 or #R$6400 address
 $7239 LD C,(HL)       ; retrieve distance from this position to start
 $723A LD B,L          ; store current position in #REGb
; Look for adjacent positions.
 $723B LD A,L          ; get current position
 $723C ADD A,IYh       ; add distance to check edge positions
 $723E LD L,A          ; move #REGhl to calculated position address
 $723F BIT 7,(HL)      ; is it an edge?
 $7241 JR NZ,$7277     ; yes, process adjacent positions
 $7243 LD A,$02        ; set distance to compare with (FRIEND)
; Return point from 'Path_Finder_Adjacent'.
@label=Path_Finder_Neighbors
*$7245 LD L,B          ; restore current position to be checked
 $7246 INC L           ; move #REGhl to RIGHT neighbor address
 $7247 CP (HL)         ; check neighbor distance
 $7248 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $724B DEC L           ; {move #REGhl to LEFT neighbor address
 $724C DEC L           ; }
 $724D CP (HL)         ; check neighbor distance
 $724E CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $7251 LD DE,$FFF8     ; distance to next neighbor
 $7254 ADD HL,DE       ; move #REGhl to UPPER-LEFT neighbor address
 $7255 CP (HL)         ; check neighbor distance
 $7256 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $7259 INC L           ; move #REGhl to UPPER-RIGHT neighbor address
 $725A CP (HL)         ; check neighbor distance
 $725B CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $725E LD DE,$0010     ; distance to next neighbor
 $7261 ADD HL,DE       ; move #REGhl to LOWER-LEFT neighbor address
 $7262 CP (HL)         ; check neighbor distance
 $7263 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $7266 INC L           ; move #REGhl to LOWER-RIGHT neighbor address
; The one and only entry point of the routine at #R$7235.
@label=Path_Finder_First
*$7267 CP (HL)         ; check neighbor distance
 $7268 CALL NC,$711C   ; if $02 (FRIEND) >= distance, update distance
 $726B POP HL          ; retreive queue head address
 $726C LD A,($7127)    ; get #R$7126+1 address (low-byte)
 $726F CP L            ; is queue empty?
 $7270 JP NZ,$7235     ; no, repeat until queue is empty
 $7273 LD A,IYl        ; get last edge position visited
 $7275 DEC A           ; return #REGa=$FF, if the edge couldn't be reached
 $7276 RET             ;

; Check Adjacent Positions
;
; Used by the routine at #R$7235.
; .
; This is an approach to update the two-distance of adjacent positions. As explained in Jack van Rijswijck's 
; #HTML(<a href="https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf" target="_blank">thesis</a>):
; "two cells are adjacent if they share a common edge on the board."                                                  
;                                                                                                                     
; I:B Current position
;   C Current distance (with a flag at 6th bit that indicates a friendly position)
;   HL Current edge position at #R$6100 or #R$6400
; O:A $00, if there is a chain of connected tokens of the same color between the two edges
;   A $02 (FRIEND), otherwise
;   IYL $00 or current position.
;
; Check if there is a chain of connected tokens.
@label=*Path_Finder_Adjnt
c$7277 LD A,$43        ; set victory distance + friendly flag                      
 $7279 CP C            ; is current distance victory and friendly?                 
 $727A JR Z,$728D      ; yes, abort path_finder
; Calculate the routine address to jump to.
 $727C LD A,(HL)       ; get current edge position
 $727D AND $07         ; convert to edge number (0..6)                             
 $727F ADD A,A         ; calculate vector table routine index                      
 $7280 LD L,A          ; set index in #REGl
 $7281 INC H           ; move #REGhl to #R$6200 or #R$6500
 $7282 LD E,(HL)       ; get low byte of vector table routine address              
 $7283 INC L           ; move #REGhl to high byte of vector table routine address
 $7284 LD D,(HL)       ; get high byte of vector table routine address             
 $7285 EX DE,HL        ; #REGhl points to the corresponding routine address
 $7286 DEC D           ; move #REGde to cyan or red board address                      
 $7287 LD E,B          ; restore pointer to current position
 $7288 LD IYl,B        ; last edge position visited = current position             
 $728A LD A,$02        ; set distance to compare with (FRIEND)
 $728C JP (HL)         ; jump to the routine and return to #R$7245
; Abort 'Path_Finder' and return to previous caller.
@label=Path_Finder_Abort
*$728D POP HL          ; restore queue head address
 $728E XOR A           ; return #REGa=$00
 $728F RET             ;

; Update Adjacents of Red Edge #0
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Red Edge #0.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6400
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6500.
@label=*PathFinder_RED_Edge_0
c$7290 EX DE,HL        ; restore pointer to current position address in #REGhl
 $7291 LD DE,$0012     ; set distance to next adjacent
 $7294 ADD HL,DE       ; move #REGhl to adjacent #2 address
 $7295 CP (HL)         ; check adjacent distance
 $7296 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7299 LD DE,$0009     ; set distance to next adjacent
 $729C ADD HL,DE       ; move #REGhl to adjacent #3 address
 $729D CP (HL)         ; check adjacent distance
 $729E CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $72A1 LD DE,$0009     ; set distance to next adjacent
 $72A4 ADD HL,DE       ; move #REGhl to adjacent #4 address
 $72A5 CP (HL)         ; check adjacent distance
 $72A6 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $72A9 LD DE,$0009     ; set distance to next adjacent
 $72AC ADD HL,DE       ; move #REGhl to adjacent #5 address
 $72AD CP (HL)         ; check adjacent distance
 $72AE CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $72B1 LD DE,$0009     ; set distance to next adjacent
 $72B4 ADD HL,DE       ; move #REGhl to adjacent #6 address
 $72B5 CP (HL)         ; check adjacent distance
 $72B6 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $72B9 LD B,IYl        ; restore current position in #REGb
 $72BB JP $7245        ; continue processing neighbors

; Update Adjacents of Red Edge #1
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Red Edge #1.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6400
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6500+2.
@label=*PathFinder_RED_Edge_1
c$72BE EX DE,HL        ; restore pointer to current position address in #REGhl
 $72BF LD DE,$0012     ; set distance to next adjacent
 $72C2 ADD HL,DE       ; move #REGhl to adjacent #3 address
 $72C3 CP (HL)         ; check adjacent distance                              
 $72C4 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $72C7 LD DE,$0009     ; set distance to next adjacent                        
 $72CA ADD HL,DE       ; move #REGhl to adjacent #4 address
 $72CB CP (HL)         ; check adjacent distance                              
 $72CC CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $72CF LD DE,$0009     ; set distance to next adjacent                        
 $72D2 ADD HL,DE       ; move #REGhl to adjacent #5 address
 $72D3 CP (HL)         ; check adjacent distance                              
 $72D4 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $72D7 LD DE,$0009     ; set distance to next adjacent                        
 $72DA ADD HL,DE       ; move #REGhl to adjacent #6 address
 $72DB CP (HL)         ; check adjacent distance
 $72DC CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $72DF LD B,IYl        ; restore current position in #REGb
 $72E1 JP $7245        ; continue processing neighbors

; Update Adjacents of Red Edge #2
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Red Edge #2.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6400
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6500+4.
@label=*PathFinder_RED_Edge_2
c$72E4 EX DE,HL        ; restore pointer to current position address in #REGhl
 $72E5 LD DE,$0012     ; set distance to next adjacent
 $72E8 ADD HL,DE       ; move #REGhl to adjacent #4 address
 $72E9 CP (HL)         ; check adjacent distance                              
 $72EA CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $72ED LD DE,$0009     ; set distance to next adjacent
 $72F0 ADD HL,DE       ; move #REGhl to adjacent #5 address
 $72F1 CP (HL)         ; check adjacent distance
 $72F2 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $72F5 LD DE,$0009     ; set distance to next adjacent
 $72F8 ADD HL,DE       ; move #REGhl to adjacent #6 address
 $72F9 CP (HL)         ; check adjacent distance                              
 $72FA CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $72FD LD DE,$FFCA     ; set distance to next adjacent
 $7300 ADD HL,DE       ; move #REGhl to adjacent #0 address
 $7301 CP (HL)         ; check adjacent distance
 $7302 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7305 LD B,IYl        ; restore current position in #REGb
 $7307 JP $7245        ; continue processing neighbors

; Update Adjacents of Red Edge #3
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Red Edge #3.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6400
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6500+6.
@label=*PathFinder_RED_Edge_3
c$730A EX DE,HL        ; restore pointer to current position address in #REGhl
 $730B LD DE,$FFE5     ; set distance to next adjacent
 $730E ADD HL,DE       ; move #REGhl to adjacent #0 address
 $730F CP (HL)         ; check adjacent distance                              
 $7310 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7313 LD DE,$0009     ; set distance to next adjacent
 $7316 ADD HL,DE       ; move #REGhl to adjacent #1 address
 $7317 CP (HL)         ; check adjacent distance
 $7318 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $731B LD DE,$0024     ; set distance to next adjacent
 $731E ADD HL,DE       ; move #REGhl to adjacent #5 address
 $731F CP (HL)         ; check adjacent distance
 $7320 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7323 LD DE,$0009     ; set distance to next adjacent
 $7326 ADD HL,DE       ; move #REGhl to adjacent #6 address
 $7327 CP (HL)         ; check adjacent distance
 $7328 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $732B LD B,IYl        ; restore current position in #REGb
 $732D JP $7245        ; continue processing neighbors

; Update Adjacents of Red Edge #4
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Red Edge #4.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6400
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6500+8.
@label=*PathFinder_RED_Edge_4
c$7330 EX DE,HL        ; restore pointer to current position address in #REGhl
 $7331 LD DE,$0012     ; set distance to next adjacent
 $7334 ADD HL,DE       ; move #REGhl to adjacent #6 address
 $7335 CP (HL)         ; check adjacent distance
 $7336 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7339 LD DE,$FFCA     ; set distance to next adjacent
 $733C ADD HL,DE       ; move #REGhl to adjacent #0 address
 $733D CP (HL)         ; check adjacent distance
 $733E CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7341 LD DE,$0009     ; set distance to next adjacent
 $7344 ADD HL,DE       ; move #REGhl to adjacent #1 address
 $7345 CP (HL)         ; check adjacent distance
 $7346 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7349 LD DE,$0009     ; set distance to next adjacent
 $734C ADD HL,DE       ; move #REGhl to adjacent #2 address
 $734D CP (HL)         ; check adjacent distance
 $734E CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7351 LD B,IYl        ; restore current position in #REGb
 $7353 JP $7245        ; continue processing neighbors

; Update Adjacents of Red Edge #5
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Red Edge #5.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6400
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6500+10.
@label=*PathFinder_RED_Edge_5
c$7356 EX DE,HL        ; restore pointer to current position address in #REGhl
 $7357 LD DE,$FFD3     ; set distance to next adjacent
 $735A ADD HL,DE       ; move #REGhl to adjacent #0 address
 $735B CP (HL)         ; check adjacent distance
 $735C CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $735F LD DE,$0009     ; set distance to next adjacent
 $7362 ADD HL,DE       ; move #REGhl to adjacent #1 address
 $7363 CP (HL)         ; check adjacent distance
 $7364 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7367 LD DE,$0009     ; set distance to next adjacent
 $736A ADD HL,DE       ; move #REGhl to adjacent #2 address
 $736B CP (HL)         ; check adjacent distance
 $736C CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $736F LD DE,$0009     ; set distance to next adjacent
 $7372 ADD HL,DE       ; move #REGhl to adjacent #3 address
 $7373 CP (HL)         ; check adjacent distance
 $7374 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7377 LD B,IYl        ; restore current position in #REGb
 $7379 JP $7245        ; continue processing neighbors

; Update Adjacents of Red Edge #6
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Red Edge #6.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6400
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6500+12.
@label=*PathFinder_RED_Edge_6
c$737C EX DE,HL        ; restore pointer to current position address in #REGhl
 $737D LD DE,$FFCA     ; set distance to next adjacent
 $7380 ADD HL,DE       ; move #REGhl to adjacent #0 address
 $7381 CP (HL)         ; check adjacent distance
 $7382 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7385 LD DE,$0009     ; set distance to next adjacent
 $7388 ADD HL,DE       ; move #REGhl to adjacent #1 address
 $7389 CP (HL)         ; check adjacent distance
 $738A CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $738D LD DE,$0009     ; set distance to next adjacent
 $7390 ADD HL,DE       ; move #REGhl to adjacent #2 address
 $7391 CP (HL)         ; check adjacent distance
 $7392 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7395 LD DE,$0009     ; set distance to next adjacent
 $7398 ADD HL,DE       ; move #REGhl to adjacent #3 address
 $7399 CP (HL)         ; check adjacent distance
 $739A CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $739D LD DE,$0009     ; set distance to next adjacent
 $73A0 ADD HL,DE       ; move #REGhl to adjacent #4 address
 $73A1 CP (HL)         ; check adjacent distance
 $73A2 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73A5 LD B,IYl        ; restore current position in #REGb
 $73A7 JP $7245        ; continue processing neighbors

; Update Adjacents of Cyan Edge #0
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Cyan Edge #0.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6100
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6200.
@label=*PathFinder_CYAN_Edge_0
c$73AA EX DE,HL        ; restore pointer to current position address in #REGhl
 $73AB INC L           ; {move #REGhl to adjacent #2 address
 $73AC INC L           ; }
 $73AD CP (HL)         ; check adjacent distance
 $73AE CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73B1 INC L           ; move #REGhl to adjacent #3 address
 $73B2 CP (HL)         ; check adjacent distance
 $73B3 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73B6 INC L           ; move #REGhl to adjacent #4 address
 $73B7 CP (HL)         ; check adjacent distance
 $73B8 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73BB INC L           ; move #REGhl to adjacent #5 address
 $73BC CP (HL)         ; check adjacent distance
 $73BD CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73C0 INC L           ; move #REGhl to adjacent #6 address
 $73C1 CP (HL)         ; check adjacent distance
 $73C2 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73C5 LD B,IYl        ; restore current position in #REGb
 $73C7 JP $7245        ; continue processing neighbors

; Update Adjacents of Cyan Edge #1
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Cyan Edge #1.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6100
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6200+2.
@label=*PathFinder_CYAN_Edge_1
c$73CA EX DE,HL        ; restore pointer to current position address in #REGhl
 $73CB INC L           ; {move #REGhl to adjacent #3 address
 $73CC INC L           ; }
 $73CD CP (HL)         ; check adjacent distance
 $73CE CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73D1 INC L           ; move #REGhl to adjacent #4 address
 $73D2 CP (HL)         ; check adjacent distance
 $73D3 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73D6 INC L           ; move #REGhl to adjacent #5 address
 $73D7 CP (HL)         ; check adjacent distance
 $73D8 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73DB INC L           ; move #REGhl to adjacent #6 address
 $73DC CP (HL)         ; check adjacent distance
 $73DD CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73E0 LD B,IYl        ; restore current position in #REGb
 $73E2 JP $7245        ; continue processing neighbors

; Update Adjacents of Cyan Edge #2
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Cyan Edge #2.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6100
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6200+4.
@label=*PathFinder_CYAN_Edge_2
c$73E5 EX DE,HL        ; restore pointer to current position address in #REGhl
 $73E6 DEC L           ; {move #REGhl to adjacent #0 address
 $73E7 DEC L           ; }
 $73E8 CP (HL)         ; check adjacent distance
 $73E9 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73EC INC L           ; {move #REGhl to adjacent #4 address
 $73ED INC L           ;
 $73EE INC L           ;
 $73EF INC L           ; }
 $73F0 CP (HL)         ; check adjacent distance
 $73F1 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73F4 INC L           ; move #REGhl to adjacent #5 address
 $73F5 CP (HL)         ; check adjacent distance
 $73F6 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73F9 INC L           ; move #REGhl to adjacent #6 address
 $73FA CP (HL)         ; check adjacent distance
 $73FB CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $73FE LD B,IYl        ; restore current position in #REGb
 $7400 JP $7245        ; continue processing neighbors

; Update Adjacents of Cyan Edge #3
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Cyan Edge #3.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6100
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6200+6.
@label=*PathFinder_CYAN_Edge_3
c$7403 EX DE,HL        ; restore pointer to current position address in #REGhl
 $7404 DEC L           ; {move #REGhl to adjacent #0 address
 $7405 DEC L           ;
 $7406 DEC L           ; }
 $7407 CP (HL)         ; check adjacent distance
 $7408 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $740B INC L           ; move #REGhl to adjacent #1 address
 $740C CP (HL)         ; check adjacent distance
 $740D CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7410 INC L           ; {move #REGhl to adjacent #5 address
 $7411 INC L           ;
 $7412 INC L           ;
 $7413 INC L           ; }
 $7414 CP (HL)         ; check adjacent distance
 $7415 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7418 INC L           ; move #REGhl to adjacent #6 address
 $7419 CP (HL)         ; check adjacent distance
 $741A CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $741D LD B,IYl        ; restore current position in #REGb
 $741F JP $7245        ; continue processing neighbors

; Update Adjacents of Cyan Edge #4
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Cyan Edge #4.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6100
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6200+8.
@label=*PathFinder_CYAN_Edge_4
c$7422 EX DE,HL        ; restore pointer to current position address in #REGhl
 $7423 INC L           ; {move #REGhl to adjacent #6 address
 $7424 INC L           ; }
 $7425 CP (HL)         ; check adjacent distance
 $7426 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7429 DEC L           ; {move #REGhl to adjacent #2 address
 $742A DEC L           ;
 $742B DEC L           ;
 $742C DEC L           ; }
 $742D CP (HL)         ; check adjacent distance
 $742E CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7431 DEC L           ; move #REGhl to adjacent #1 address
 $7432 CP (HL)         ; check adjacent distance
 $7433 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7436 DEC L           ; move #REGhl to adjacent #0 address
 $7437 CP (HL)         ; check adjacent distance
 $7438 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $743B LD B,IYl        ; restore current position in #REGb
 $743D JP $7245        ; continue processing neighbors

; Update Adjacents of Cyan Edge #5
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Cyan Edge #5.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6100
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6200+10.
@label=*PathFinder_CYAN_Edge_5
c$7440 EX DE,HL        ; restore pointer to current position address in #REGhl
 $7441 DEC L           ; {move #REGhl to adjacent #3 address
 $7442 DEC L           ; }
 $7443 CP (HL)         ; check adjacent distance
 $7444 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7447 DEC L           ; move #REGhl to adjacent #2 address
 $7448 CP (HL)         ; check adjacent distance
 $7449 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $744C DEC L           ; move #REGhl to adjacent #1 address
 $744D CP (HL)         ; check adjacent distance
 $744E CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7451 DEC L           ; move #REGhl to adjacent #0 address
 $7452 CP (HL)         ; check adjacent distance
 $7453 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7456 LD B,IYl        ; restore current position in #REGb
 $7458 JP $7245        ; continue processing neighbors

; Update Adjacents of Cyan Edge #6
;
; Used by the routine at #R$7277.
; .
; Update adjacents two-distance of Cyan Edge #6.
;
; I:A $02 (FRIEND)
;   DE Current position address at #R$6100
;   IYL Current position
; O:A $02 (FRIEND)
;   B Current position
;
; The address of this routine is found in the #R$6200+12.
@label=*PathFinder_CYAN_Edge_6
c$745B EX DE,HL        ; restore pointer to current position address in #REGhl
 $745C DEC L           ; {move #REGhl to adjacent #4 address
 $745D DEC L           ; }
 $745E CP (HL)         ; check adjacent distance
 $745F CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7462 DEC L           ; move #REGhl to adjacent #3 address
 $7463 CP (HL)         ; check adjacent distance
 $7464 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7467 DEC L           ; move #REGhl to adjacent #2 address
 $7468 CP (HL)         ; check adjacent distance
 $7469 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $746C DEC L           ; move #REGhl to adjacent #1 address
 $746D CP (HL)         ; check adjacent distance
 $746E CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7471 DEC L           ; move #REGhl to adjacent #0 address
 $7472 CP (HL)         ; check adjacent distance
 $7473 CALL NC,$711C   ; if $02 (FRIEND) >= adjacent distance, update distance
 $7476 LD B,IYl        ; restore current position in #REGb
 $7478 JP $7245        ; continue processing neighbors

; Get Speccy Score
;
; Used by the routines at #R$6F7F, #R$6FB4, #R$700E, #R$7052 and #R$70AC.
; .
; Calculate board score depending on speccy color.
;
; O:A $FF, if speccy can't reach his opposite edge
;   A $00, if speccy has a chain of connected tokens between the two edges or if player cant reach his edge
;   A Speccy heuristic evaluation, otherwise
@label=*PathFinder_Score
c$747B LD A,($6199)    ; get #R$6199
 $747E CP $02          ; is it FRIEND?
 $7480 JR Z,$74B3      ; yes, calculate CYAN score
; This routine continues into #R$7482.

; Get Red Score
;
; Calculate RED score based on Jack van Rijswijck's #HTML(<a href="https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf" target="_blank">thesis</a>):
; #LIST
; { i. Calculate RED and CYAN two-distance metric. }
; { ii. Calculate RED heuristic evaluation. }
; LIST#
; .
; The routine at #R$747B continues here.
;
; O:A $FF, if red can't reach his opposite edge
;   A $00, if there a chain of connected red tokens between the two edges or if cyan can't reach his edge
;   A Red heuristic evaluation, otherwise
;
; Calculate RED two-distance.
@label=PathFinder_RedScore
c$7482 CALL $71B5      ; calculate RED two-distance from LEFT to RIGHT edge
 $7485 RET Z           ; if red has a chain of connected tokens, return #REGa=$00
 $7486 EX AF,AF'       ; save first result in #REGa'
 $7487 CALL $71F7      ; calculate RED two-distance from RIGHT to LEFT edge
 $748A LD B,A          ; save second result in #REGb
 $748B EX AF,AF'       ; restore first result
 $748C SUB B           ; subtract both results
 $748D LD A,B          ; restore second result
 $748E RET Z           ; if red can't reach his opposite edge, return #REGa=$FF
; Calculate CYAN two-distance.
 $748F CALL $7141      ; calculate CYAN two-distance from UP to DOWN edge
 $7492 EX AF,AF'       ; save result in #REGa'
 $7493 CALL $717D      ; calculate CYAN two-distance from DOWN to UP edge
 $7496 LD B,A          ; save second result in #REGb
 $7497 EX AF,AF'       ; restore first result
 $7498 SUB B           ; subtract both results
 $7499 RET Z           ; if cyan can't reach his opposite edge, return #REGa=$00
; Calculate RED potentials.
 $749A LD HL,$6409     ; #REGhl points to #R$6400+9 address
 $749D LD DE,$6451     ; #REGde points to #R$6450+1 address
 $74A0 CALL $74F1      ; calculate RED potentials                                
 $74A3 LD ($6197),BC   ; store them at #R$6197
; Calculate CYAN potentials.
 $74A7 LD HL,$6109     ; #REGhl points to #R$6100+9 address
 $74AA LD DE,$6151     ; #REGde points to #R$6150+1 address
 $74AD CALL $74F1      ; calculate CYAN potentials
 $74B0 JP $74E1        ; calculate heuristic evaluation

; Get Cyan Score
;
; Used by the routine at #R$747B.
; .
; Calculate CYAN score based on Jack van Rijswijck's #HTML(<a href="https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf" target="_blank">thesis</a>):
; #LIST
; { i. Calculate CYAN and RED two-distance metric. }
; { ii. Calculate CYAN heuristic evaluation. }
; LIST#
;
; O:A $FF, if cyan can't reach his opposite edge
;   A $00, if there a chain of connected cyan tokens between the two edges or if red can't reach his edge
;   A Cyan heuristic evaluation, otherwise
;
; Calculate CYAN two-distance.
@label=*PathFinder_CyanScore
c$74B3 CALL $7141      ; calculate CYAN two-distance from UP to DOWN edge
 $74B6 RET Z           ; if cyan has a chain of connected tokens, return #REGa=$00
 $74B7 EX AF,AF'       ; save first result in #REGa'                             
 $74B8 CALL $717D      ; calculate CYAN two-distance from DOWN to UP edge
 $74BB LD B,A          ; save second result in #REGb                             
 $74BC EX AF,AF'       ; restore first result                                    
 $74BD SUB B           ; subtract both results                                   
 $74BE LD A,B          ; restore second result                                   
 $74BF RET Z           ; if cyan can't reach his opposite edge, return #REGa=$FF
; Calculate RED two-distance.
 $74C0 CALL $71B5      ; calculate RED two-distance from LEFT to RIGHT edge
 $74C3 EX AF,AF'       ; save result in #REGa'                                  
 $74C4 CALL $71F7      ; calculate RED two-distance from RIGHT to LEFT edge
 $74C7 LD B,A          ; save second result in #REGb                            
 $74C8 EX AF,AF'       ; restore first result                                   
 $74C9 SUB B           ; subtract both results                                  
 $74CA RET Z           ; if red can't reach his opposite edge, return #REGa=$00
; Calculate CYAN potentials.
 $74CB LD HL,$6109     ; #REGhl points to #R$6100+9 address
 $74CE LD DE,$6151     ; #REGde points to #R$6150+1 address
 $74D1 CALL $74F1      ; calculate CYAN potentials
 $74D4 LD ($6197),BC   ; store them at #R$6197
; Calculate RED potentials.
 $74D8 LD HL,$6409     ; #REGhl points to #R$6400+9 address
 $74DB LD DE,$6451     ; #REGde points to #R$6450+1 address
 $74DE CALL $74F1      ; calculate RED potentials
; This routine continues into #R$74E1.

; Calculate Heuristic Evaluation
;
; Used by the routine at #R$7482.
; .
; The original evaluation function (from cyan perspective) is described in Jack van Rijswijck's #HTML(<a href="https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf" target="_blank">thesis</a>) as:
; .
; #TABLE(default,centre)
; { =h e = M (pC - pR) - (aC - aR) }
; TABLE#
; .
; where:
; #LIST
; { pC = cyan board potential }
; { pR = red board potential }
; { aC = cyan attack mobility }
; { aR = red attack mobility }
; { M = a large number }
; LIST#
; .
; This adaptation uses an "invert" result to better fit BRAINIAC process.
; .
; The routine at #R$74B3 continues here.
;                                                                                                         
; I:B Opponent attack mobility
;  :C Opponent board potential
; O:A Heuristic evaluation
@label=*PathFinder_Evaluation
c$74E1 LD HL,$6198     ; #REGhl points to #R$6197+1 address
 $74E4 LD A,B          ; get opponent's attack mobility
 $74E5 SUB (HL)        ; subtract attack mobilities #HTML(&rarr;) (aC - aR)
 $74E6 LD E,A          ; save the result in #REGe
 $74E7 DEC L           ; move #REGhl to #R$6197 address
 $74E8 LD A,C          ; get opponent's board potential
 $74E9 SUB (HL)        ; subtract potentials #HTML(&rarr;) (pC - pR)
 $74EA ADD A,A         ; {multiply by 8 #HTML(&rarr;) M (pC - pR)
 $74EB ADD A,A         ;
 $74EC ADD A,A         ; }
 $74ED SUB E           ; subtract result of attack mobilities subtraction #HTML(&rarr;) M (pC - pR) - (aC - aR)
 $74EE XOR $80         ; invert sign for easier further comparative
 $74F0 RET             ; return #REGa = -1 * (M (pC - pR) - (aC - aR))

; Get Potential and Attack Mobility
;
; Used by the routines at #R$7482, #R$74B3, #R$7568, #R$7573 and #R$7524.
; .
; Calculate board potential and attack mobility (#R$6197). As explained in Jack van Rijswijck's #HTML(<a href=
; "https://webdocs.cs.ualberta.ca/~hayward/theses/jackmsc.pdf" target="_blank">thesis</a>):
; .
; #LIST
; { A cell's Cyan potential is defined as the sum of its Cyan two-distance to both cyan edges; its Red potential is the
; sum of its Red two-distance to both red edges. The board potential is defined as the lowest potential that occurs on
; the board. }
; { The attack mobility is defined for each player as the number of cells that realize that player's board potential. }
; LIST#
;
; I:HL #R$6100 or #R$6400 address
;   DE #R$6400 or #R$6100 address
; O:B Attack Mobility
;   C Board Potential
@label=PathFinder_Potentials
c$74F1 LD BC,$00FF     ; initialize attack mobility and board potential
 $74F4 LD IYl,$3D      ; number of cells to be checked (loop counter)
@label=Potentials_Loop
*$74F7 LD A,(HL)       ; get cell's two-distance pointed by #REGhl
 $74F8 CP $40          ; is cell occupied or border?                      
 $74FA JR NC,$7512     ; yes, skip to next cell                           
 $74FC CP $04          ; cell distance was not updated?                   
 $74FE JR C,$751A      ; yes, set cell potential as "infinite" and skip   
 $7500 LD A,(DE)       ; get cell's two-distance pointed by #REGde
 $7501 CP $04          ; cell distance was not updated?                   
 $7503 JR C,$751A      ; yes, set cell potential as "infinite" and skip   
 $7505 ADD A,(HL)      ; sum both two-distances (calculate cell potential)
 $7506 LD (HL),A       ; save potential in the cell pointed by #REGhl
 $7507 CP C            ; is the new potential >= board potential?         
 $7508 JP NC,$750E     ; yes, check attack mobility                       
 $750B LD C,A          ; no, board potential = new potential              
 $750C LD B,$01        ; restart attack mobility
@label=Potentials_Mobility
*$750E JP NZ,$7512     ; if (potential <> last potential) skip to next cell 
 $7511 INC B           ; else, increment attack mobility                   
@label=Potentials_Next                                                     
*$7512 INC E           ; move to next cell of each board                   
 $7513 INC L                                                               
 $7514 DEC IYl         ; decrement loop counter                            
 $7516 JP NZ,$74F7     ; repeat until end of boards                        
 $7519 RET                                                                 
@label=Potentials_Infinte
*$751A SET 7,(HL)      ; set cell potential as "infinite"
 $751C INC E           ; move to next cell of each board
 $751D INC L
 $751E DEC IYl         ; decrement loop counter
 $7520 JP NZ,$74F7     ; repeat until end of boards
 $7523 RET

; Search Candidates
;
; Used by the routines at #R$6F7F, #R$6FB4 and #R$7052.
; .
; Search candidates based on score result and boards potentials.
;
; I:A $FF, $00 or heuristic result
;   IX #R$7F00 address
; O:IX First candidate address
@label=*PathFinder_Candidates
c$7524 LD (IX+$00),$00 ; set candidates endmarker               
 $7528 OR A            ; #REGa = $00?
 $7529 JR Z,$7568      ; yes, fill candidates for winner color
 $752B INC A           ; #REGa = $FF?
 $752C JR Z,$7573      ; yes, fill candidates for defeated color
; If #REGa is not $00 nor $FF, fill candidates from total potentials
 $752E LD HL,$6109     ; #REGhl points to #R$6100+9 addr.
 $7531 LD DE,$6409     ; #REGde points to #R$6400+9 addr.
 $7534 CALL $74F1      ; process candidates from total potentials
 $7537 LD A,C          ; set board potential in #REGa
 $7538 EX AF,AF'       ; save board potential                    
 $7539 LD D,B          ; store attack mobility                   
 $753A LD E,IXl        ; store candidates position
; Insert the second best board potentials in candidates area.
@label=Candidates_2ndBest
*$753C LD L,$09        ; #REGhl points to #R$6100+9
 $753E INC C           ; increment board potential                           
 $753F LD A,C          ; #REGa=second best potential
 $7540 CP $20          ; is potential >= $20? (2nd best max potential)       
 $7542 JR NC,$7557     ; yes, stop searching 2nd best potential              
 $7544 LD B,$3D        ; number of cells to be checked (loop counter)
@label=Candidates_2ndBest_Loop
*$7546 CP (HL)         ; is current board potential = 2nd best board potential?
 $7547 JP NZ,$754F     ; no, skip to next potential
 $754A INC IXl         ; {yes, insert candidate
 $754C LD (IX+$00),L   ; }
@label=Candidates_2ndBest_Next
*$754F INC L           ; move #REGhl to next board potential address
 $7550 DJNZ $7546      ; repeat for each cell                   
 $7552 LD A,IXl        ; #REGa=current candidates position
 $7554 CP E            ; new candidates inserted?
 $7555 JR Z,$753C      ; no, repeat until new candidates inserted
@label=Candidates_2ndBest_Exit
*$7557 LD B,D          ; restore attack mobility
 $7558 EX AF,AF'       ; restore board potential
; This entry point is used by the routines at #R$7568 and #R$7573 with #REGa=Board Potential, #REGb=Attack Mobility and #REGhl pointing to #R$6100 or #R$6400.
; .
; Insert the best board potentials in candidates area.
@label=Candidates_Best
*$7559 LD L,$08        ; move #REGhl to first board potential address (-1)
@label=Candidates_Best_Loop
*$755B INC L           ; move #REGhl to next board potential address
 $755C CP (HL)         ; is current board potential equal to best board potential?
 $755D JP NZ,$755B     ; no, next potential
 $7560 INC IXl         ; {yes, insert candidate
 $7562 LD (IX+$00),L   ; }
 $7565 DJNZ $755B      ;
 $7567 RET             ; repeat for each cell

; Search Candidates for Winner/Defeated
;
; Used by the routine at #R$7524.
; .
; Search candidates for winner color.
@label=*Candidates_Winner
c$7568 LD A,($6199)    ; check #R$6199
 $756B CP $02          ; is it friend?                            
 $756D JP Z,$7580      ; yes, fill candidates from cyan potentials
 $7570 JP $7593        ; no, fill candidates from red potentials
; Search candidates for defeated color.
@label=Candidates_Defeat
*$7573 LD A,($6199)    ; check #R$6199
 $7576 CP $02          ; is it friend?                           
 $7578 JR Z,$758D      ; yes, fill candidates from red potentials
; If RED is defeated, candidates are chosen from cyan board potentials.
 $757A CALL $7141      ; calculate cyan two-distance from up to down edge
 $757D CALL $717D      ; calculate cyan two-distance from down to up edge
@label=Candidates_Cyan_Potential
*$7580 LD HL,$6109     ; #REGhl points to #R$6100+9 addr.
 $7583 LD DE,$6151     ; #REGde points to #R$6150+1 addr.
 $7586 CALL $74F1      ; calculate cyan potentials                             
 $7589 LD A,C          ; set board potential in #REGa
 $758A JP $7559        ; fill only the best candidates
; If CYAN is defeated, candidates are chosen from red board potentials
@label=Candidates_Red
*$758D CALL $71B5      ; calculate red two-distance from left to right edge
 $7590 CALL $71F7      ; calculate red two-distance from right to left edge
@label=Candidates_Red_Potential
*$7593 LD HL,$6409     ; #REGhl points #R$6400+9 addr.
 $7596 LD DE,$6451     ; #REGde points #R$6450+1 addr.
 $7599 CALL $74F1      ; calculate red potentials                                
 $759C LD A,C          ; set board potential in #REGa
 $759D JP $7559        ; fill only the best candidates

; Calculate Victory Path
;
; Used by the routine at #R$6C83.
; .
; Calculate current player victory path.
;
; O:A $FF, if there isn't a victory path
;   A Start position (-1) of the victory path, otherwise
;   HL #R$6000 or #R$6300
@label=*PathFinder_VictoryPath
c$75A0 LD A,($619E)    ; get #R$619E
 $75A3 CP $05          ; is it cyan?
 $75A5 JR Z,$75B3      ; yes, check victory path for cyan player
 $75A7 CALL $71B5      ; execute Path_Finder RED from LEFT to RIGHT
 $75AA LD HL,$6445     ; #REGhl points to #R$6400+69 address
 $75AD CALL $75BF      ; prepare board to calculate victory path
 $75B0 JP $71BE        ; calculate RED victory path and return
@label=PathFinder_VPath_Cyan
*$75B3 CALL $7141      ; execute Path_Finder CYAN from UP to DOWN
 $75B6 LD HL,$6145     ; #REGhl points to #R$6100+69 address
 $75B9 CALL $75BF      ; prepare board to calculate victory path
 $75BC JP $714A        ; calculate CYAN victory path and return

; Setup Board for Victory Path
;
; Used by the routine at #R$75A0.
; .
; Update input board, changing $43 (victory distance + friendly flag) to $01, everything else to $7E (ENEMY).
; .
; After executing #R$7141 or #R$71B5, execute this routine and then execute #R$714A or #R$71BE to find a victory path.
; .
; Coded by Einar Saukas.
;                                                                                                                   
; I:HL #R$6100+69 or #R$6400+69
@label=*PathFinder_PrepareBoard
c$75BF LD A,$43        ; set victory distance + friendly flag
 $75C1 LD C,$07        ; 7 rows
@label=PrepareBoard_Row
*$75C3 LD B,$07        ; 7 columns
@label=PrepareBoard_Column
*$75C5 CP (HL)         ; is it win condition?
 $75C6 LD (HL),$01     ; save $01 by default
 $75C8 JR Z,$75CC      ; yes, next position
 $75CA LD (HL),$7E     ; no, save $7E (ENEMY)
@label=PrepareBoard_Next
*$75CC DEC L           ; #REGhl points to next board position
 $75CD DJNZ $75C5      ; repeat for each column
 $75CF DEC L           ; {skip borders
 $75D0 DEC L           ; }
 $75D1 DEC C           ; decrement rows
 $75D2 JR NZ,$75C3     ; repeat for each row
 $75D4 RET             ;

; Bright and Animate Victory Path
;
; Used by the routine at #R$6CB9.
; .
; Animate and highlight the hexagons included in shortest path when match ends.
;
; I:B Start position of the victory path
;   HL #R$6000 or #R$6300
@label=*PathFinder_BrightPath
c$75D5 LD A,($619E)    ; get #R$619E
 $75D8 PUSH AF         ; save it at stack
 $75D9 ADD A,$40       ; apply bright attribute                           
 $75DB LD ($619E),A    ; save new #R$619E
 $75DE INC H           ; {move #REGhl to the start position of the victory path
 $75DF LD L,B          ; }
 $75E0 LD C,(HL)       ; set victory path length in #REGc
 $75E1 JR $7601        ; animate and highlight the hexagon position
@label=BrightPath_Neighbor
*$75E3 INC L           ; move #REGhl to LEFT neighbor address
 $75E4 CP (HL)         ; is it the same as victory path length?         
 $75E5 JR Z,$7601      ; yes, animate and highlight the hexagon position
 $75E7 DEC L           ; {move #REGhl to RIGHT neighbor address
 $75E8 DEC L           ; }
 $75E9 CP (HL)         ; is it the same as victory path length?         
 $75EA JR Z,$7601      ; yes, animate and highlight the hexagon position
 $75EC LD A,L          ; {move #REGhl to UPPER-RIGHT neighbor address
 $75ED SUB $08         ;
 $75EF LD L,A          ; }
 $75F0 LD A,C          ; restore victory path length in #REGa
 $75F1 CP (HL)         ; is it the same as victory path length?         
 $75F2 JR Z,$7601      ; yes, animate and highlight the hexagon position
 $75F4 INC L           ; move #REGhl to UPPER-LEFT neighbor address
 $75F5 CP (HL)         ; is it the same as victory path length?         
 $75F6 JR Z,$7601      ; yes, animate and highlight the hexagon position
 $75F8 LD A,L          ; {move #REGhl to LOWER-RIGHT neighbor address
 $75F9 ADD A,$10       ;
 $75FB LD L,A          ; }
 $75FC LD A,C          ; restore victory path length in #REGa
 $75FD CP (HL)         ; is it the same as victory path length?         
 $75FE JR Z,$7601      ; yes, animate and highlight the hexagon position
 $7600 INC L           ; move #REGh to LOWER-LEFT neighbor address
@label=BrightPath_Position
*$7601 PUSH BC         ; store victory path length                          
 $7602 PUSH HL         ; store current position pointer                     
 $7603 CALL $6D81      ; convert a board position into a board indexes      
 $7606 CALL $6DBC      ; animate hexagon sprite on the screen               
 $7609 LD IX,$64E7     ; #REGix points to #R$64E7
 $760D CALL $76C7      ; play sound effect                                  
 $7610 POP HL          ; restore current position pointer                   
 $7611 POP BC          ; restore victory path length                        
 $7612 DEC C           ; decrement victory path length                      
 $7613 LD A,C          ; set victory path length in #REGa
 $7614 CP $03          ; has reached victory path length?                   
 $7616 JR NZ,$75E3     ; repeat for each neighbor until reach victory length
 $7618 POP AF          ; {restore current #R$619E
 $7619 LD ($619E),A    ;
 $761C RET             ; }

; Timer Interrupt
;
; Used by the routines at #R$5CA1 and #R$6C00.
; .
; Interrupt routine to manage players' timers.
@label=*Timer_Interrupt
c$761D PUSH AF         ; store #REGaf register
 $761E EXX             ; store #REGbc, #REGde and #REGhl registers
 $761F LD A,($62E9)    ; check #R$62E9
 $7622 OR A            ; is timer stopped?
 $7623 JP Z,$764C      ; yes, exit routine                            
 $7626 LD HL,$62ED     ; #REGhl points to #R$62ED address
 $7629 DEC A           ; is red timer on?                             
 $762A JP NZ,$7630     ; yes, check interrupt counter
 $762D LD HL,$62EA     ; #REGhl points to #R$62EA address
@label=Timer_Counters
*$7630 DEC (HL)        ; decrement interrupt counter       
 $7631 JP NZ,$764C     ; if not 0, exit routine            
 $7634 LD (HL),$32     ; restart interrupt counter         
 $7636 INC HL          ; move #REGhl to seconds counter address
 $7637 LD A,$01        ; {increment seconds counter
 $7639 ADD A,(HL)      ; }
 $763A DAA             ; convert to BCD (Binary-Coded-Decimal)
 $763B LD (HL),A       ; store seconds                        
 $763C CP $60          ; 60 seconds reached?                  
 $763E JP NZ,$7649     ; no, show timer                       
 $7641 LD (HL),$00     ; restart seconds counter              
 $7643 INC HL          ; move #REGhl to minutes counter address
 $7644 LD A,$01        ; {increment minutes counter
 $7646 ADD A,(HL)      ; }
 $7647 DAA             ; convert to BCD (Binary-Coded-Decimal)
 $7648 LD (HL),A       ; store minutes
@label=Timer_Show
*$7649 CALL $7650      ; display timer on the screen
@label=Timer_Exit
*$764C EXX             ; restore #REGbc, #REGde and #REGhl registers
 $764D POP AF          ; restore #REGaf register
 $764E EI              ; enable interrupts
 $764F RET             ;

; Display Timer
;
; Used by the routines at #R$761D and #R$769D.
; .
; Display a timer on the screen.
@label=*Timer_Display
c$7650 LD DE,$62EF     ; #REGde points to #R$62ED minutes counter address
 $7653 LD BC,$48E2     ; #REGbc points to red's minutes screen address
 $7656 LD A,($62E9)    ; check #R$62E9
 $7659 DEC A           ; is cyan timer on?                          
 $765A JP NZ,$7663     ; no, jump to display minutes counter        
 $765D LD DE,$62EC     ; #REGde points to #R$62EA minutes counter address
 $7660 LD BC,$4078     ; #REGbc points to cyan's minutes screen address
@label=Timer_Display_Min
*$7663 CALL $7668      ; display minutes counter on screen   
 $7666 DEC DE          ; #REGde points to seconds counter address
 $7667 INC C           ; #REGbc points to seconds screen address
@label=Timer_Display_MinSec
*$7668 LD A,(DE)       ; set min/sec counter in #REGa
 $7669 RRA             ; {move tens digit to the first 4th bits of #REGa
 $766A RRA             ;
 $766B RRA             ;
 $766C RRA             ; }
 $766D CALL $7671      ; display tens digit on screen
 $7670 LD A,(DE)       ; set min/sec counter in #REGa
@label=Timer_Display_Digit
*$7671 AND $0F         ; discard the last 4th bits of the digit      
 $7673 PUSH BC         ; store digit screen address                  
 $7674 LD HL,$6497     ; #REGhl points to #R$6497 address
 $7677 ADD A,A         ; {a digit is 8 bytes long
 $7678 ADD A,A         ;
 $7679 ADD A,A         ; }
 $767A ADD A,L         ; {set digit index in #REGhl
 $767B LD L,A          ; }
 $767C LD A,(HL)       ; get digit tile                    
 $767D LD (BC),A       ; put it on screen address          
 $767E INC B           ; move #REGbc to next pixel-line address
 $767F INC L           ; move #REGhl to next digit tile address
 $7680 LD A,(HL)       ; get digit tile                        
 $7681 LD (BC),A       ; put it on screen address              
 $7682 INC B           ; move #REGbc to next pixel-line address
 $7683 INC L           ; move #REGhl to next digit tile address
 $7684 LD A,(HL)       ; get digit tile                        
 $7685 LD (BC),A       ; put it on screen address              
 $7686 INC B           ; move #REGbc to next pixel-line address
 $7687 INC L           ; move #REGhl to next digit tile address
 $7688 LD A,(HL)       ; get digit tile                        
 $7689 LD (BC),A       ; put it on screen address              
 $768A INC B           ; move #REGbc to next pixel-line address
 $768B INC L           ; move #REGhl to next digit tile address
 $768C LD A,(HL)       ; get digit tile                        
 $768D LD (BC),A       ; put it on screen address              
 $768E INC B           ; move #REGbc to next pixel-line address
 $768F INC L           ; move #REGhl to next digit tile address
 $7690 LD A,(HL)       ; get digit tile                        
 $7691 LD (BC),A       ; put it on screen address              
 $7692 INC B           ; move #REGbc to next pixel-line address
 $7693 INC L           ; move #REGhl to next digit tile address
 $7694 LD A,(HL)       ; get digit tile                        
 $7695 LD (BC),A       ; put it on screen address
 $7696 INC B           ; move #REGbc to next pixel-line address
 $7697 INC L           ; move #REGhl to next digit tile address
 $7698 LD A,(HL)       ; get digit tile                        
 $7699 LD (BC),A       ; put it on screen address
 $769A POP BC          ; restore digit screen address
 $769B INC C           ; move screen address to next column
 $769C RET             ;

; Display All Timers
;
; Used by the routine at #R$6C4B.
; .
; Display cyan and red timers.
@label=*Timer_Display_All
c$769D LD A,$01        ; {set #R$62E9 on for cyan timer
 $769F LD ($62E9),A    ; }
 $76A2 CALL $7650      ; display cyan timer
 $76A5 LD A,$02        ; {set #R$62E9 on for red timer
 $76A7 LD ($62E9),A    ; }
 $76AA CALL $7650      ; display red timer
 $76AD XOR A           ; {stop timers
 $76AE LD ($62E9),A    ; }
 $76B1 RET             ;

; Reset Timers
;
; Used by the routine at #R$6C4B.
; .
; Initialize cyan and red timers.
@label=*Timer_Reset
c$76B2 LD HL,$62EA     ; #REGhl points to #R$62EA address
 $76B5 LD (HL),$32     ; set interrupt counter (1/50 seconds)     
 $76B7 INC HL          ; move #REGhl to cyan's seconds counter address
 $76B8 LD (HL),$00     ; reset seconds counter                    
 $76BA INC HL          ; move #REGhl to cyan's minutes counter address
 $76BB LD (HL),$00     ; reset minutes counter                    
 $76BD INC HL          ; move #REGhl to red's interrupt counter
 $76BE LD (HL),$32     ; set interrupt counter (1/50 seconds)     
 $76C0 INC HL          ; move #REGhl to red's seconds counter address
 $76C1 LD (HL),$00     ; reset seconds counter                    
 $76C3 INC HL          ; move #REGhl to red's minutes counter address
 $76C4 LD (HL),$00     ; reset minutes counter
 $76C6 RET             ;

; Play Sound Effect
;
; Used by the routines at #R$7875, #R$6D36, #R$6C83 and #R$75D5.
; .
; Play a sound effect (tone) defined by many parameters.
; #HTML(Coded with <a href="https://shiru.untergrund.net/software.shtml" target="_blank">BeepFX</a> player tool by Shiru.)
;
; I:IX Tone parameters address
@label=*Sound_FX
c$76C7 DI              ; disable interrupts
 $76C8 LD C,(IX+$00)   ; {#REGbc=frames
 $76CB LD B,(IX+$01)   ; }
 $76CE LD E,(IX+$02)   ; {#REGde=frame length
 $76D1 LD D,(IX+$03)   ; }
 $76D4 PUSH DE         ; {store frame length in #REGiy
 $76D5 POP IY          ; }
 $76D7 LD E,(IX+$04)   ; {#REGde=pitch
 $76DA LD D,(IX+$05)   ; }
 $76DD LD HL,$0000     ; reset #REGhl
@label=Sound_FX_Frames
*$76E0 PUSH BC         ; store frames              
 $76E1 PUSH IY         ; {restore frame length in #REGbc
 $76E3 POP BC          ; }
@label=Sound_FX_FrameLength
*$76E4 ADD HL,DE       ; #REGhl=incremented pitch
 $76E5 LD A,H          ; compares with fixed duty cycle ($80 for 50% square wave)
 $76E6 CP $80          ; if (incremented pitch < duty cycle) ...
 $76E8 SBC A,A         ; ... #REGa=%11111111 else #REGa=%00000000
 $76E9 AND $10         ; toggling bit 4 controls the internal speaker            
 $76EB OR $00          ; keep border unchanged, dummy (7t)                       
 $76ED OUT ($FE),A     ; send bit to internal speaker                            
 $76EF LD A,($0000)    ; dummy (13t)                                             
 $76F2 DEC BC          ; decrement frame length                                  
 $76F3 LD A,B          ; check frame length                                      
 $76F4 OR C            ; frame length = 0?                                       
 $76F5 JP NZ,$76E4     ; no, repeat "frame length" times (loop = 88t)            
 $76F8 LD C,(IX+$06)   ; {#REGbc=pitch slide
 $76FB LD B,(IX+$07)   ; }
 $76FE EX DE,HL        ; #REGhl=current pitch
 $76FF ADD HL,BC       ; increment pitch with pitch slide
 $7700 EX DE,HL        ; #REGde=new pitch
 $7701 POP BC          ; restore frames                  
 $7702 DEC BC          ; decrement frames                
 $7703 LD A,B          ; check frames                    
 $7704 OR C            ; frames = 0?                     
 $7705 JR NZ,$76E0     ; no, repeat "frames" times       
 $7707 EI              ; enable interrupts
 $7708 RET             ;

; Clear Screen
;
; Used by the routines at #R$7974, #R$6C1D and #R$7875.
; .
; Fill in black the whole screen area and attributes area.
@label=*Screen_Clear
c$7709 LD HL,$4000     ; #REGhl points to start of the screen address
 $770C LD DE,$4001     ; #REGde points to next byte of the screen address
 $770F LD (HL),L       ; set first pixel-byte in black
 $7710 LD BC,$1AFF     ; length of screen area (-1 already set) + attributes area 
 $7713 LDIR            ; fill the rest of screen area and attributes area in black
 $7715 RET             ;

; Draw Board Letters
;
; Used by the routines at #R$7974 and #R$6C1D.
; .
; Draw the two rows of letters on the screen (a..g).
@label=*Screen_Letters
c$7716 LD HL,$4566     ; #REGhl points to first letter screen address (top row)
 $7719 LD IX,$5866     ; #REGix points to first letter attribute address (top row)   
 $771D CALL $7727      ; draw top row of letters                                 
 $7720 LD HL,$516D     ; #REGhl points to first letter screen address (bottom row)
 $7723 LD IX,$5A6D     ; #REGix points to first letter attribute address (bottom row)
@label=Screen_Letters_Row
*$7727 LD DE,$665E     ; #REGde points to #R$665E address
 $772A LD B,$07        ; number of letters (loop counter)
@label=Screen_Letter_Loop
*$772C PUSH HL         ; store letter screen address   
 $772D CALL $6DF4      ; draw letter at screen address 
 $7730 POP HL          ; restore letter screen address 
 $7731 INC L           ; {move #REGhl to next screen address
 $7732 INC L           ; }
 $7733 LD (IX+$00),$05 ; {set letter color (2 bytes, CYAN)
 $7737 LD (IX+$20),$05 ; }
 $773B INC IXl         ; {move #REGix to next attribute address
 $773D INC IXl         ; }
 $773F DJNZ $772C      ; repeat for each letter
 $7741 RET             ;

; Draw Board Numbers
;
; Used by the routines at #R$7974 and #R$6C1D.
; .
; Draw the two columns of numbers on the screen (1..7).
@label=*Screen_Numbers
c$7742 LD DE,$66A4     ; #REGde points to #R$66A4 address
 $7745 LD IY,$62F0     ; #REGiy points to #R$62F0 addresses
 $7749 LD IX,$58A5     ; #REGix points to first number attribute address
 $774D LD B,$07        ; number of numbers (loop counter)
@label=Screen_Number_Loop
*$774F LD L,(IY+$00)   ; {#REGhl points to number screen address
 $7752 LD H,(IY+$01)   ; }
 $7755 PUSH HL         ; store pointer to number screen address  
 $7756 PUSH DE         ; store pointer to sprite address         
 $7757 CALL $6DF4      ; draw number at screen address           
 $775A POP DE          ; restore pointer to sprite address       
 $775B POP HL          ; restore pointer to number screen address
 $775C LD (IX+$00),$02 ; {set number color (2 bytes, RED)
 $7760 LD (IX+$20),$02 ; }
 $7764 LD A,L          ; {move #REGhl to screen address of the 2nd column
 $7765 ADD A,$0F       ;
 $7767 LD L,A          ; }
 $7768 CALL $6DF4      ; draw number at screen address
 $776B LD (IX+$0F),$02 ; {set number color (2 bytes, RED)
 $776F LD (IX+$2F),$02 ; }
 $7773 LD A,B          ; save loop counter                     
 $7774 LD BC,$0041     ; displacement of next attribute address
 $7777 ADD IX,BC       ; move #REGix to next attribute address
 $7779 INC IY          ; {move #REGiy to next number screen address
 $777B INC IY          ; }
 $777D LD B,A          ; restore loop counter  
 $777E DJNZ $774F      ; repeat for each number
 $7780 RET             ;

; Draw Screen Frame
;
; Used by the routines at #R$7974 and #R$6C1D.
; .
; Draw the screen frame on the screen.
@label=*Screen_Frame
c$7781 LD DE,$6229     ; #REGde points to #R$6229 address ("Level")
 $7784 LD HL,$4009     ; #REGhl points to screen address of the string
 $7787 CALL $6F59      ; print "Level"                                       
 $778A CALL $77C6      ; draw the vertical bars of frame                     
 $778D LD BC,$628E     ; #REGbc points to #R$628E address
 $7790 LD HL,$4000     ; #REGhl points to the screen address of the up-border
 $7793 CALL $7799      ; draw up-border                                      
 $7796 LD HL,$50E0     ; #REGhl points to the screen address of the bottom-border
@label=Screen_Frame_Border
*$7799 LD IXl,$20      ; border width in bytes (loop counter)
@label=Screen_Frame_Loop
*$779C LD A,(BC)       ; get tile index                
 $779D CP $FF          ; is it -1?                     
 $779F JR Z,$77A7      ; yes, there is no tile to print
 $77A1 LD DE,$650E     ; #REGde points to #R$650E address
 $77A4 CALL $6F68      ; print frame tile
@label=Screen_Frame_Next
*$77A7 INC L           ; #REGhl points to the next screen address (next column)
 $77A8 INC BC          ; #REGbc points to the next tile index
 $77A9 DEC IXl         ; decrement loop counter                              
 $77AB JR NZ,$779C     ; repeat for each tile                                
 $77AD LD IX,$5807     ; #REGix points to the "concave left" tile attribute address
 $77B1 LD (IX+$00),$08 ; color tile (BLUE PAPER)
 $77B5 LD (IX+$0A),$08 ; color "concave right" tile
 $77B9 LD IX,$5AF1     ; #REGix points to the "convex left" tile attribute address
 $77BD LD (IX+$00),$01 ; color tile (BLUE INK)
 $77C1 LD (IX+$04),$01 ; color "convex right" tile
 $77C5 RET             ;

; Draw Vertical Bars
;
; Used by the routine at #R$7781.
; .
; Draw the vertical bars of the frame on the screen.
@label=*Screen_Vertical_Bars
c$77C6 LD HL,$4020     ; #REGhl points to left bar screen address
 $77C9 CALL $77CF      ; draw left bar                        
 $77CC LD HL,$403F     ; #REGhl points to right bar screen address
@label=Screen_Vertical_Bar
*$77CF LD B,$B0        ; number of pixel lines (loop counter)
@label=Screen_Vertical_Loop
*$77D1 LD (HL),$3C     ; draw pixel byte of bar (00111100)
 $77D3 CALL $6E00      ; move #REGhl to the next pixel-line address
 $77D6 DJNZ $77D1      ; repeat for each pixel line
 $77D8 RET             ;

; Draw Fixed Tokens
; 
; Used by the routine at #R$6C1D.
; .
; Draw the fixed tokens on the screen.
@label=*Screen_Tokens
c$77D9 LD A,$05        ; set token color (CYAN)
 $77DB LD HL,$44BA     ; #REGhl points to the fixed cyan token screen address
 $77DE CALL $77E6      ; draw cyan fixed token                           
 $77E1 LD A,$02        ; set token color (RED)
 $77E3 LD HL,$5424     ; #REGhl points to the fixed red token screen address
@label=Screen_Tokens_Draw
*$77E6 LD ($619E),A    ; save token color at #R$619E
 $77E9 CALL $6E0F      ; color fixed token area                                    
 $77EC LD (IX+$40),A   ; {the fixed tokens are 3 bytes (attributes) high, so we have to color the remaining 2 bytes that have not been colored
 $77EF LD (IX+$41),A   ; }
 $77F2 LD DE,$663E     ; #REGde points to #R$663E address
 $77F5 JP $6DE1        ; draw fixed token

; Draw Timer Quotes
;
; Used by the routine at #R$6C1D.
; .
; Draw the timer quotes ('  '') on the screen.
@label=*Screen_Timer_Quotes
c$77F8 LD IX,$407A     ; #REGix points to the screen address of the cyan timer quotes 
 $77FC LD (IX+$00),$08 ; draw 1st half of simple quote (')                        
 $7800 LD (IX+$03),$0A ; draw 1st half of double quotes (")                       
 $7804 INC IXh         ; move #REGix to the next screen pixel-line
 $7806 LD (IX+$00),$08 ; draw 2nd half of simple quote (')                        
 $780A LD (IX+$03),$0A ; draw 2nd half of double quotes (")                       
 $780E LD IXh,$58      ; move #REGix to the attribute address
 $7811 LD (IX+$00),$07 ; color simple quote                                       
 $7815 LD (IX+$03),$07 ; color double quotes                                      
 $7819 LD IX,$48E4     ; #REGix points to the screen address of the red timer quotes
 $781D LD (IX+$00),$08 ; draw 1st half of simple quote (')                        
 $7821 LD (IX+$03),$0A ; draw 1st half of double quotes (")                       
 $7825 INC IXh         ; move #REGix to the next screen pixel-line
 $7827 LD (IX+$00),$08 ; draw 2nd half of simple quote (')                        
 $782B LD (IX+$03),$0A ; draw 2nd half of double quotes (")                       
 $782F LD IXh,$59      ; move #REGix to the attribute address
 $7832 LD (IX+$00),$07 ; color simple quote                                       
 $7836 LD (IX+$03),$07 ; color double quotes
 $783A RET             ;

; Apply Color to Statics Items
;
; Used by the routine at #R$6C1D.
; .
; Apply color to some statics items of the screen.
@label=*Screen_Color_Statics
c$783B LD IX,$5878     ; #REGix points to the attr. address of the cyan player timer
 $783F LD C,$07        ; set color in #REGc (WHITE)
 $7841 CALL $786B      ; apply color                                               
 $7844 LD IXl,$98      ; #REGix points to the attr. address of the cyan player name
 $7847 LD C,$05        ; set color in #REGc (CYAN)
 $7849 CALL $786B      ; apply color                                               
 $784C LD IX,$5918     ; #REGix points to the att. address of the cyan player messages
 $7850 LD C,$47        ; set color in #REGc (BRIGHT+WHITE)
 $7852 CALL $786B      ; apply color                                               
 $7855 LD IXl,$E2      ; #REGix points to the attr. address of the red player timer
 $7858 LD C,$07        ; set color in #REGc (WHITE)
 $785A CALL $786B      ; apply color                                               
 $785D LD IX,$5A02     ; #REGix points to the attr. address of the red player name
 $7861 LD C,$02        ; set color in #REGc (RED)
 $7863 CALL $786B      ; apply color                                               
 $7866 LD IXl,$82      ; #REGix points to the attr. address of the red player messages
 $7869 LD C,$47        ; set color in #REGc (BRIGHT+WHITE)
; This entry point is used by the routines at #R$6F0E, #R$6F15, #R$6F2E, #R$6F35, #R$6F3C, #R$7974, #R$79F7 and #R$7AA3 with #REGc=color
; attribute and #REGix pointing to string attribute address.
@label=Screen_Apply_Color
*$786B LD B,$06        ; number of bytes to be colored (loop counter)
; This entry point is used by the routines at #R$7974, #R$79F7, #R$7AA3, #R$7B5A, #R$7BDE and #R$7875 with #REGb=number of bytes,
; #REGc=color attribute and #REGix pointing to string attribute address.
@label=Screen_Apply_Color_Loop
*$786D LD (IX+$00),C   ; apply color                          
 $7870 INC IXl         ; move #REGix to the next attribute address
 $7872 DJNZ $786D      ; repeat for each byte
 $7874 RET             ;

; Show Last Level Screen
;
; Used by the routine at #R$6C33.
; .
; Show last level screen and wait for a new game level to restart game.
@label=*Screen_Last_Level
c$7875 LD DE,$683C     ; #REGde points #R$683C address
 $7878 LD HL,$50AD     ; #REGhl points to string screen address
 $787B CALL $6F59      ; print "Press any key"                                 
 $787E LD IX,$5AAD     ; #REGix points to string attributes address
 $7882 LD BC,$0D38     ; #REGb=string length (loop counter), #REGc=WHITE PAPER
 $7885 CALL $786D      ; apply color to string area                            
 $7888 CALL $6EC5      ; wait for a key pressed                                
 $788B CALL $7709      ; fill in black the whole screen area and attributes area
 $788E CALL $7C4E      ; draw menu hexagons ("HEX 2")                          
 $7891 LD IX,$59C7     ; #REGix points to "CONGRATULATIONS" attributes address
 $7895 LD BC,$11C7     ; #REGb=string length (loop counter), #REGc=FLASH+WHITE
 $7898 CALL $786D      ; apply color to string area                            
 $789B LD DE,$68B4     ; #REGde points to #R$68B4 address
 $789E LD HL,$48C7     ; #REGhl points to string screen address
 $78A1 CALL $6F59      ; print "CONGRATULATIONS"                               
 $78A4 LD IX,$64EF     ; #REGix points to #R$64EF address
 $78A8 CALL $76C7      ; play sound fx                                         
 $78AB DI              ; disable interrupts                                    
 $78AC LD IX,$5A42     ; #REGix points to "Well done!..." string attributes address
 $78B0 LD BC,$1C07     ; #REGb=string length (loop counter), #REGc=WHITE
 $78B3 CALL $786D      ; apply color to string area                            
 $78B6 LD DE,$68C6     ; #REGde points #R$68C6 address
 $78B9 LD HL,$5042     ; #REGhl points to string screen address
 $78BC CALL $6F59      ; print "Well done!..."                                 
 $78BF LD IXl,$82      ; #REGix points to "Choose..." string attributes address
 $78C2 LD B,$18        ; string length-4 (loop counter)                        
 $78C4 CALL $786D      ; apply color to string area                            
 $78C7 LD (IX+$01),$78 ; {set BRIGHT+WHITE PAPER for last characters ("1-4")
 $78CB LD (IX+$02),$78 ;
 $78CF LD (IX+$03),$78 ; }
 $78D3 INC DE          ; move #REGde to #R$68C6+29 address
 $78D4 LD L,$82        ; #REGhl points to string screen address
 $78D6 CALL $6F59      ; print "Choose..."
@label=Screen_Choose_Level
*$78D9 CALL $6EC5      ; wait for a key pressed              
 $78DC CP $31          ; is it < '1' ?                       
 $78DE JR C,$78D9      ; yes, wait for a key pressed         
 $78E0 CP $35          ; is it >= '5' ?                      
 $78E2 JR NC,$78D9     ; yes, wait for a key pressed         
 $78E4 SUB $31         ; convert ASCII into level number (-1)
 $78E6 LD HL,$619D     ; #REGhl points #R$619D address
 $78E9 LD (HL),A       ; save chosen game level (-1)
 $78EA RET             ;

; Apply Color to Three-in-a-Row
;
; Used by the routine at #R$6CB9.
; .
; Color the three-in-a-row marks according to the current three row counter.
@label=*Screen_ThreeRow
c$78EB LD HL,$619C     ; #REGhl points to #R$619C address
 $78EE LD C,(HL)       ; save level color in #REGc
 $78EF CALL $7907      ; clear all three-in-a-row marks  
 $78F2 LD A,($620F)    ; #REGa=#R$620F
 $78F5 OR A            ; is it 0?                        
 $78F6 RET Z           ; yes, return                     
 $78F7 DEC A           ; is it 1?                        
 $78F8 JR Z,$7903      ; yes, color first mark           
 $78FA DEC A           ; is it 2?                        
 $78FB JR Z,$7900      ; yes color 2nd and 1st marks     
 $78FD LD (IX+$00),C   ; color 3rd mark
@label=Screen_ThreeRow_2
*$7900 LD (IX+$01),C   ; color 2nd mark
@label=Screen_ThreeRow_1
*$7903 LD (IX+$02),C   ; color 1st mark
 $7906 RET             ;

; Clear Three-in-a-Row Marks
;
; Used by the routines at #R$7974, #R$7AA3, #R$6C33 and #R$78EB.
; .
; Clear all three-in-a-row marks by applying them BLUE color.
;
; O:IX Three-in-a-row marks attribute address
@label=*Screen_Clear_ThreeRow
c$7907 LD IX,$5AF2     ; #REGix points to attribute address of three-in-a-row marks
 $790B LD (IX+$00),$01 ; {clear all three-in-a-row marks (color attribute=BLUE)
 $790F LD (IX+$01),$01 ;
 $7913 LD (IX+$02),$01 ; }
 $7917 RET             ;

; Apply Color to Frame
;
; Used by the routines at #R$7974 and #R$6C33.
; .
; Set up frame color and print level number depending on current level.
;
; I:HL #R$619D
@label=*Screen_Frame_Color
c$7918 LD B,$00        ; {set game level in #REGbc
 $791A LD C,(HL)       ; }
 $791B LD A,$30        ; {convert game level number to game level character
 $791D ADD A,C         ; }
 $791E LD HL,$400F     ; #REGhl points to screen address of game level            
 $7921 CALL $6F65      ; print game level
 $7924 LD HL,$620F     ; #REGhl points to #R$6210-1 (adjusted for index 0)
 $7927 ADD HL,BC       ; use #REGbc as index for color map address
 $7928 LD A,(HL)       ; #REGa=level color
 $7929 CALL $793E      ; color the frame according to the current level       
 $792C AND $07         ; mask color                                           
 $792E LD ($619C),A    ; save at #R$619C
 $7931 RLA             ; {rotate to text level color
 $7932 RLA             ;
 $7933 RLA             ; }
 $7934 LD HL,$5808     ; #REGhl points to attribute address of level text
 $7937 LD B,$09        ; length of level text (loop counter)
@label=Screen_Level_Loop
*$7939 LD (HL),A       ; apply color to level text                                 
 $793A INC L           ; move #REGhl to attribute address of next character of level text
 $793B DJNZ $7939      ; repeat for each character of level text
 $793D RET             ;

; Apply Color to Frame Tiles
;
; Used by the routine at #R$7918.
; .
; Apply color to the frame tiles.
;
; I:A Color to apply
;
; Apply color to up row.
@label=*Screen_Tiles_Color
c$793E LD HL,$5801     ; #REGhl points to attribute address of the the frame tile 
 $7941 LD B,$06        ; number of tiles (loop counter)
@label=Screen_Tiles_URow1
*$7943 LD (HL),A       ; apply color                           
 $7944 INC L           ; move #REGhl to the next attribute address
 $7945 DJNZ $7943      ; repeat for each tile                 
 $7947 LD L,$12        ; move #REGhl to the next attribute address
 $7949 LD B,$0D        ; number of tiles (loop counter)
@label=Screen_Tiles_URow2
*$794B LD (HL),A       ; apply color                          
 $794C INC L           ; move #REGhl to the next attribute address
 $794D DJNZ $794B      ; repeat for each tile
; Apply color to vertical bars.
 $794F LD L,$00        ; move #REGhl to the next attribute address
 $7951 LD DE,$001F     ; attribute address displacement (for each bar)
 $7954 LD C,$03        ; number of screen thirds (outer loop counter)
@label=Screen_Tiles_VBar1
*$7956 LD B,$08        ; number of tiles (inner loop counter)
@label=Screen_Tiles_VBar2
*$7958 LD (HL),A       ; apply color                          
 $7959 ADD HL,DE       ; move #REGhl to the right column
 $795A LD (HL),A       ; apply color                          
 $795B INC L           ; move #REGhl to the next attribute address
 $795C DJNZ $7958      ; repeat for each tile                 
 $795E INC H           ; move #REGhl to the next screen third
 $795F DEC C           ; decrement number of thirds           
 $7960 JR NZ,$7956     ; repeat for each third
; Apply color to bottom row.
 $7962 LD HL,$5AE1     ; #REGhl points to attribute address of the the frame tile
 $7965 LD B,$10        ; number of tiles (loop counter)
@label=Screen_Tiles_BRow1
*$7967 LD (HL),A       ; apply color                          
 $7968 INC L           ; move #REGhl to the next attribute address
 $7969 DJNZ $7967      ; repeat for each tile                 
 $796B LD L,$F6        ; move #REGhl to the next attribute address
 $796D LD B,$09        ; number of tiles (loop counter)
@label=Screen_Tiles_BRow2
*$796F LD (HL),A       ; apply color                          
 $7970 INC L           ; move #REGhl to the next attribute address
 $7971 DJNZ $796F      ; repeat for each tile
 $7973 RET             ;

; Show Main Menu Screen
;
; Used by the routine at #R$6C00.
; .
; Show main menu and wait for an option.
@label=*Screen_Menu
c$7974 CALL $7709      ; fill in black the whole screen area and attributes area
 $7977 CALL $7C4E      ; draw menu hexagons ("HEX 2")
; Clear menu text area. This entry point is used by the routine at #R$7BDE.
@label=Screen_Menu_Strings
*$797A LD HL,$5980     ; #REGhl points to menu text area attributes address
 $797D LD DE,$5981     ; #REGde points to next byte of menu text area attr. address
 $7980 LD (HL),$00     ; set first attribute text area in black
 $7982 LD BC,$017F     ; #REGbc=length of text area attributes (-1 already set)
 $7985 LDIR            ; set the rest of text area attributes in black
; Print menu options.
 $7987 LD IX,$59CA     ; #REGix points to "Start new game" string attr. address (+1)
 $798B LD (IX-$01),$78 ; set color of first letter (BRIGHT+WHITE PAPER)
 $798F LD BC,$0D47     ; #REGb=string length-1 (loop counter), #REGc=BRIGHT+WHITE
 $7992 CALL $786D      ; apply color to string area
 $7995 LD DE,$6780     ; #REGde points to #R$6780 address
 $7998 LD HL,$48C9     ; #REGhl points to string screen address
 $799B CALL $6F59      ; print "Start new game"
 $799E LD IX,$5A2A     ; #REGix points to "How to play" string attributes address (+1)
 $79A2 LD (IX-$01),$78 ; set color of first letter (BRIGHT+WHITE PAPER)
 $79A6 LD B,$0A        ; string length-1 (loop counter)                           
 $79A8 CALL $786D      ; apply color to string area                               
 $79AB INC DE          ; move #REGde to #R$6780+1 address
 $79AC LD HL,$5029     ; #REGhl points to string screen address
 $79AF CALL $6F59      ; print "How to play"                                      
 $79B2 LD IXl,$8A      ; #REGix points to "Credits" string attributes address (+1)
 $79B5 LD (IX-$01),$78 ; set color of first letter (BRIGHT+WHITE PAPER)
 $79B9 CALL $786B      ; apply color to string area                               
 $79BC INC DE          ; move #REGde to #R$6780+2 address
 $79BD LD L,$89        ; #REGhl points to string screen address
 $79BF CALL $6F59      ; print "Credits"
; Wait for an option.
@label=Screen_Menu_Options
*$79C2 CALL $6EC5      ; wait for a key pressed                          
 $79C5 CP $73          ; is it 's'?                                      
 $79C7 RET Z           ; yes, return to #R$6C1D
 $79C8 CP $63          ; is it 'c'?                                      
 $79CA JP Z,$7BDE      ; yes, show credits
 $79CD CP $68          ; is it 'h'?                                      
 $79CF JR NZ,$79C2     ; no, repeat until key pressed = 's' or 'c' or 'h'
; Show "How to play" main screen.
 $79D1 CALL $7709      ; fill in black the whole screen area and attributes area
 $79D4 CALL $7716      ; draw the two rows of letters on the screen (a..g)
 $79D7 CALL $7742      ; draw the two columns of numbers on the screen (1..7)
 $79DA CALL $7781      ; draw the screen frame
 $79DD LD HL,$619D     ; #REGhl points to #R$619D address
 $79E0 INC (HL)        ; game level=1
 $79E1 CALL $7918      ; set up frame color depending on current level
 $79E4 CALL $7907      ; clear all three-in-a-row marks
 $79E7 LD DE,$684A     ; #REGde points to #R$684A address
 $79EA LD HL,$50DB     ; #REGhl points to string screen address
 $79ED CALL $6F59      ; print "Next"
 $79F0 INC DE          ; move #REGde to #R$684A+1 address
 $79F1 LD HL,$50C1     ; #REGhl points to string screen address
 $79F4 CALL $6F59      ; print "Back"
; This routine continues into #R$79F7.

; Show "How to play" Red Screen
;
; Used by the routine at #R$7AA3.
; .
; The routine at #R$7974 continues here.
; .
; Show "How to play" red screen and wait for an option.
@label=*Screen_How2Play_RED
c$79F7 LD HL,$585E     ; #REGhl points to cyan text area attributes address (-24)
 $79FA CALL $7C88      ; clear text area attributes
 $79FD CALL $6DA1      ; draw an empty hexagons board
; Print help text for red.
 $7A00 LD IX,$5A01     ; #REGix points to "Connect" string attributes address
 $7A04 LD BC,$0707     ; #REGb=string length (loop counter), #REGc=color (WHITE)
 $7A07 CALL $786D      ; apply color to string area                            
 $7A0A LD DE,$685D     ; #REGde points to #R$685D address
 $7A0D LD HL,$5001     ; #REGhl points to string screen address
 $7A10 CALL $6F59      ; print "Connect"                                       
 $7A13 LD IXl,$21      ; #REGix points to "left and" string attributes address
 $7A16 LD B,$08        ; string length (loop counter)                          
 $7A18 CALL $786D      ; apply color to string area                            
 $7A1B INC DE          ; move #REGde to #R$6865 address
 $7A1C LD L,$21        ; #REGhl points to string screen address
 $7A1E CALL $6F59      ; print "left and"                                      
 $7A21 LD IXl,$41      ; #REGix points to "right" string attributes address
 $7A24 LD B,$05        ; set string length (loop counter)                      
 $7A26 CALL $786D      ; apply color to string area                            
 $7A29 LD DE,$6875     ; #REGde points #R$6875 address
 $7A2C LD L,$41        ; #REGhl points to string screen address
 $7A2E CALL $6F59      ; print "right"                                         
 $7A31 LD IXl,$61      ; #REGix points to "borders" string attributes address
 $7A34 LD B,$07        ; set string length (loop counter)                      
 $7A36 CALL $786D      ; apply color to string area                            
 $7A39 LD DE,$6880     ; #REGde points to #R$6880 address
 $7A3C LD L,$61        ; #REGhl points to string screen address
 $7A3E CALL $6F59      ; print "borders"                                       
 $7A41 LD IXl,$81      ; #REGix points to "to win" string attributes address
 $7A44 CALL $786B      ; apply color to string area                            
 $7A47 INC DE          ; move #REGde to #R$6888 address
 $7A48 LD L,$81        ; #REGhl points to string screen address
 $7A4A CALL $6F59      ; print "to win"                                        
 $7A4D LD IX,$59E3     ; #REGix points to "RED" string attributes address
 $7A51 LD BC,$0342     ; #REGb=string length (loop counter), #REGc=BRIGHT+RED
 $7A54 CALL $786D      ; apply color to string area                            
 $7A57 LD DE,$6854     ; #REGde points to #R$6854 address
 $7A5A LD HL,$48E3     ; #REGhl points to string screen address
 $7A5D CALL $6F59      ; print "RED"
; Draw red sample board.
 $7A60 LD IY,$673A     ; #REGiy points to #R$673A address
 $7A64 LD DE,$663E     ; #REGde points to #R$663E address
 $7A67 LD B,$07        ; number of bright+red tokens (loop counter)
 $7A69 LD A,$42        ; set token color (BRIGHT+RED)
 $7A6B LD ($619E),A    ; save at #R$619E
 $7A6E CALL $7C73      ; draw tokens                                     
 $7A71 LD B,$02        ; number of red tokens (loop counter)             
 $7A73 LD A,$02        ; set token color (RED)
 $7A75 LD ($619E),A    ; save at #R$619E
 $7A78 CALL $7C73      ; draw tokens                                     
 $7A7B LD B,$09        ; number of cyan tokens (loop counter)            
 $7A7D LD A,$05        ; set token color (CYAN)
 $7A7F LD ($619E),A    ; save at #R$619E
 $7A82 CALL $7C73      ; draw tokens
; Wait for "Next" option pressed.
 $7A85 LD IX,$5AC1     ; #REGix points to "Back" string attribute address
 $7A89 LD BC,$0400     ; #REGb=string length (loop counter), #REGc=color (BLACK)
 $7A8C CALL $786D      ; hide "Back" string                                      
 $7A8F LD IXl,$DC      ; #REGix points to "Next" string attribute address (+1)
 $7A92 LD (IX-$01),$78 ; set color of first letter (BRIGHT+WHITE PAPER)
 $7A96 LD BC,$0347     ; #REGb=string length-1 (loop counter), #REGc=BRIGHT+WHITE
 $7A99 CALL $786D      ; apply color to string area
@label=Screen_How2PlayRED_End
*$7A9C CALL $6EC5      ; wait for a key pressed            
 $7A9F CP $6E          ; is it 'n'?                        
 $7AA1 JR NZ,$7A9C     ; no, repeat until key pressed = 'n'
; This routine continues into #R$7AA3.

; Show "How to play" Cyan Screen
;
; Used by the routine at #R$7B5A.
; .
; The routine at #R$79F7 continues here.
; .
; Show "How to play" cyan screen and wait for an option.
@label=*Screen_How2Play_CYAN
c$7AA3 LD HL,$580F     ; #REGhl points to level number attribute address        
 $7AA6 RES 7,(HL)      ; reset flash attribute                              
 $7AA8 LD H,$40        ; #REGhl points to level number screen address
 $7AAA LD A,$31        ; set level number (char)                            
 $7AAC CALL $6F65      ; print '1'                                          
 $7AAF CALL $7907      ; clear all three-in-a-row marks                     
 $7AB2 LD HL,$59C9     ; #REGhl points to red text area attributes address (-24)
 $7AB5 CALL $7C88      ; clear text area attributes                         
 $7AB8 CALL $6DA1      ; draw an empty hexagons board
; Print help text for cyan.
 $7ABB LD IX,$5898     ; #REGix points to "Connect" string attributes address      
 $7ABF LD BC,$0707     ; #REGb=string length (loop counter), #REGc=color (WHITE)
 $7AC2 CALL $786D      ; apply color to string area                            
 $7AC5 LD DE,$685D     ; #REGde points to #R$685D address
 $7AC8 LD HL,$4098     ; #REGhl points to string screen address
 $7ACB CALL $6F59      ; print "Connect"
 $7ACE LD IXl,$B9      ; #REGix points to "up and" string attributes address
 $7AD1 CALL $786B      ; apply color to string area                            
 $7AD4 LD DE,$686E     ; #REGde points #R$686E address
 $7AD7 LD L,$B9        ; #REGhl points to string screen address
 $7AD9 CALL $6F59      ; print "up and"                                        
 $7ADC LD IXl,$DB      ; #REGix points to "down" string attributes address
 $7ADF LD B,$04        ; string length (loop counter)                          
 $7AE1 CALL $786D      ; apply color to string area                            
 $7AE4 LD DE,$687B     ; #REGde points #R$687B address
 $7AE7 LD L,$DB        ; #REGhl points to string screen address
 $7AE9 CALL $6F59      ; print "down"                                          
 $7AEC LD IXl,$F8      ; #REGix points to "borders" string attributes address      
 $7AEF LD B,$07        ; string length (loop counter)                          
 $7AF1 CALL $786D      ; apply color to string area                            
 $7AF4 INC DE          ; move #REGde to #R$6880 address
 $7AF5 LD L,$F8        ; #REGhl points to string screen address
 $7AF7 CALL $6F59      ; print "borders"                                       
 $7AFA LD IX,$5919     ; #REGix points to "to win" string attributes address       
 $7AFE CALL $786B      ; apply color to string area                            
 $7B01 INC DE          ; move #REGde to #R$6888 address
 $7B02 LD HL,$4819     ; #REGhl points to string screen address
 $7B05 CALL $6F59      ; print "to win"                                        
 $7B08 LD IX,$587A     ; #REGix points to "CYAN" string attributes address         
 $7B0C LD BC,$0445     ; #REGb=string length (loop counter), #REGc=BRIGHT+CYAN
 $7B0F CALL $786D      ; apply color to string area        
 $7B12 LD DE,$6858     ; #REGde points to #R$6858 address
 $7B15 LD HL,$407A     ; #REGhl points to string screen address
 $7B18 CALL $6F59      ; print "CYAN"
; Draw cyan sample board.
 $7B1B LD IY,$675E     ; #REGiy points to #R$675E address
 $7B1F LD DE,$663E     ; #REGde points to #R$663E address
 $7B22 LD B,$07        ; number of bright+cyan tokens (loop counter)
 $7B24 LD A,$45        ; set token color (BRIGHT+CYAN)
 $7B26 LD ($619E),A    ; save at #R$619E
 $7B29 CALL $7C73      ; draw tokens
 $7B2C LD B,$02        ; number of cyan tokens (loop counter)
 $7B2E LD A,$05        ; set token color (CYAN)
 $7B30 LD ($619E),A    ; save at #R$619E
 $7B33 CALL $7C73      ; draw tokens
 $7B36 LD B,$08        ; number of red tokens (loop counter)
 $7B38 LD A,$02        ; set token color (RED)
 $7B3A LD ($619E),A    ; save at #R$619E
 $7B3D CALL $7C73      ; draw tokens
; Wait for "Next" or "Back" option pressed.
 $7B40 LD IX,$5AC2     ; #REGix points to "Back" string attributes address (+1)
 $7B44 LD (IX-$01),$78 ; set color of first letter
 $7B48 LD BC,$0347     ; #REGb=string length (-1), #REGc=color (BRIGHT+WHITE)
 $7B4B CALL $786D      ; apply color to string area
@label=Screen_How2PlayCYAN_End
*$7B4E CALL $6EC5      ; wait for a key pressed                   
 $7B51 CP $62          ; is it 'b'?                               
 $7B53 JP Z,$79F7      ; yes, show "How to play" red screen
 $7B56 CP $6E          ; is it 'n'?                               
 $7B58 JR NZ,$7B4E     ; no, repeat until key pressed = 'n' or 'b'
; This routine continues into #R$7B5A.

; Show "How to play" Level-Up Screen
;
; The routine at #R$7AA3 continues here.
; .
; Show "How to play" level-up screen and wait for an option.
@label=Screen_How2Play_LevelUp
c$7B5A LD HL,$585E     ; #REGhl points to cyan text area attributes address (-24)
 $7B5D CALL $7C88      ; clear text area attributes
; Print help text for level-up.
 $7B60 LD IX,$5A21     ; #REGix points to "Win three" string attributes address
 $7B64 LD BC,$0907     ; #REGb=string length (loop counter), #REGc=color (WHITE)
 $7B67 CALL $786D      ; apply color to string area                            
 $7B6A LD DE,$688F     ; #REGde points to #R$688F address
 $7B6D LD HL,$5021     ; #REGhl points to string screen address
 $7B70 CALL $6F59      ; print "Win three"                                     
 $7B73 LD IXl,$41      ; #REGix points to "times in" string attributes address
 $7B76 LD B,$08        ; string length (loop counter)                          
 $7B78 CALL $786D      ; apply color to string area
 $7B7B INC DE          ; move #REGde to #R$688F+1 address
 $7B7C LD L,$41        ; #REGhl points to string screen address
 $7B7E CALL $6F59      ; print "times in"
 $7B81 LD IXl,$61      ; #REGix points to "a row to" string attributes address
 $7B84 LD B,$08        ; string length (loop counter)                          
 $7B86 CALL $786D      ; apply color to string area                            
 $7B89 INC DE          ; move #REGde to #R$688F+2 address
 $7B8A LD L,$61        ; #REGhl points to string screen address
 $7B8C CALL $6F59      ; print "a row to"                                      
 $7B8F LD IXl,$81      ; #REGix points to "level up" string attributes address
 $7B92 LD B,$08        ; string length (loop counter)
 $7B94 CALL $786D      ; apply color to string area                            
 $7B97 INC DE          ; move #REGde to #R$688F+3 address
 $7B98 LD L,$81        ; #REGhl points to string screen address
 $7B9A CALL $6F59      ; print "level up"
; Reset bright of cyan tokens.
 $7B9D LD IY,$675E     ; #REGiy points to #R$675E address
 $7BA1 LD DE,$663E     ; #REGde points to #R$663E address
 $7BA4 LD B,$07        ; number of bright+cyan tokens (loop counter)
 $7BA6 LD A,$05        ; set new token color (CYAN)
 $7BA8 LD ($619E),A    ; save at #R$619E
 $7BAB CALL $7C73      ; draw tokens
; Set flash attribute of level number and three-in-a-row marks.
 $7BAE LD HL,$580F     ; #REGhl points to level number attribute address
 $7BB1 SET 7,(HL)      ; set flash attribute                          
 $7BB3 LD HL,$400F     ; #REGhl points to level number screen address
 $7BB6 LD A,$32        ; set new level ('2')
 $7BB8 CALL $6F65      ; print new level                              
 $7BBB LD IX,$5AF2     ; #REGix points to three-in-a-row attribute address
 $7BBF LD (IX+$00),$B8 ; {set flash attributes
 $7BC3 LD (IX+$01),$B8 ;
 $7BC7 LD (IX+$02),$B8 ; }
; Wait for "Next" or "Back" options pressed.
@label=Screen_How2Play_End
*$7BCB CALL $6EC5      ; wait for a key pressed                   
 $7BCE CP $62          ; is it 'b'?                               
 $7BD0 JP Z,$7AA3      ; yes, show "How to play" cyan screen
 $7BD3 CP $6E          ; is it 'n'?                               
 $7BD5 JR NZ,$7BCB     ; no, repeat until key pressed = 'b' or 'n'
 $7BD7 LD HL,$619D     ; #REGhl points to #R$619D address
 $7BDA DEC (HL)        ; game level=0
 $7BDB JP $7974        ; return to main menu

; Show Credits Screen
;
; Used by the routine at #R$7974.
; .
; Show credits screen.
@label=*Screen_Menu_Credits
c$7BDE LD IX,$5984     ; #REGix points to "Design..." string attributes address
 $7BE2 LD BC,$1947     ; #REGb=string length (loop counter), #REGc=BRIGHT+WHITE
 $7BE5 CALL $786D      ; apply color to string area                            
 $7BE8 LD DE,$67A3     ; #REGde points to #R$67A3 address
 $7BEB LD HL,$4884     ; #REGhl points to string screen address
 $7BEE CALL $6F59      ; print "Design..."                                     
 $7BF1 LD IXl,$C4      ; #REGix points to "Code..." string attributes address
 $7BF4 LD B,$19        ; string length (loop counter)                          
 $7BF6 CALL $786D      ; apply color to string area                            
 $7BF9 INC DE          ; move #REGde to #R$67A3+1 address
 $7BFA LD L,$C4        ; #REGhl points to string screen address
 $7BFC CALL $6F59      ; print "Code..."                                       
 $7BFF LD IXl,$E4      ; #REGix points to "Einar Saukas" string attributes address
 $7C02 LD B,$18        ; string length (loop counter)
 $7C04 CALL $786D      ; apply color to string area                            
 $7C07 INC DE          ; move #REGde to #R$67A3+2 address
 $7C08 LD L,$E4        ; #REGhl points to string screen address
 $7C0A CALL $6F59      ; print "Einar Saukas"                                  
 $7C0D LD IX,$5A24     ; #REGix points to "Font..." string attributes address
 $7C11 LD B,$18        ; string length (loop counter)                          
 $7C13 CALL $786D      ; apply color to string area
 $7C16 INC DE          ; move #REGde to #R$67A3+3 address
 $7C17 LD HL,$5024     ; #REGhl points to string screen address
 $7C1A CALL $6F59      ; print "Font..."
 $7C1D LD IXl,$64      ; #REGix points to "Graphics..." string attributes address
 $7C20 LD B,$18        ; string length (loop counter)
 $7C22 CALL $786D      ; apply color to string area
 $7C25 INC DE          ; move #REGde to #R$67A3+4 address
 $7C26 LD L,$64        ; #REGhl points to string screen address
 $7C28 CALL $6F59      ; print "Graphics..."
 $7C2B LD IXl,$84      ; #REGix points to "Antonio Luque" string attributes address
 $7C2E LD B,$19        ; string length (loop counter)
 $7C30 CALL $786D      ; apply color to string area
 $7C33 INC DE          ; move #REGde to #R$67A3+5 address
 $7C34 LD L,$84        ; #REGhl points to string screen address
 $7C36 CALL $6F59      ; print "Antonio Luque"
 $7C39 LD IXl,$E9      ; #REGix points to "Press any key" string attributes address
 $7C3C LD BC,$0D38     ; #REGb=string length (loop counter), #REGc=WHITE PAPER
 $7C3F CALL $786D      ; apply color to string area                            
 $7C42 INC DE          ; move #REGde to #R$683C address
 $7C43 LD L,$E9        ; #REGhl points to string screen address
 $7C45 CALL $6F59      ; print "Press any key"                                 
 $7C48 CALL $6EC5      ; wait for a key pressed                                
 $7C4B JP $797A        ; return to main menu screen

; Draw Main Menu Hexagons
;
; Used by the routines at #R$7974 and #R$7875.
; .
; Draw the main menu hexagons ("HEX 2") on screen.
@label=*Screen_Hexagons
c$7C4E LD IY,$66EA     ; #REGiy points to #R$66EA addresses
 $7C52 LD A,$07        ; set hexagon color (WHITE)
 $7C54 LD ($619E),A    ; save at #R$619E
 $7C57 LD DE,$657E     ; #REGde points to #R$657E address
 $7C5A LD B,$1C        ; number of empty hexagons (loop counter)    
 $7C5C CALL $7C73      ; draw empty hexagons                        
 $7C5F LD A,$05        ; set token color (CYAN)
 $7C61 LD ($619E),A    ; save at #R$619E
 $7C64 LD DE,$663E     ; #REGde points to #R$663E address
 $7C67 LD B,$06        ; number of cyan tokens (loop counter)
 $7C69 CALL $7C73      ; draw cyan tokens
 $7C6C LD A,$02        ; set token color (RED)
 $7C6E LD ($619E),A    ; save at #R$619E
 $7C71 LD B,$06        ; number of red tokens (loop counter)
; This routine continues into #R$7C73.

; Draw "How to play" Hexagons
;
; Used by the routines at #R$7C4E, #R$79F7, #R$7AA3 and #R$7B5A.
; .
; The routine at #R$7C4E continues here.
;
; I:B Number of hexagons to draw
;   DE Hexagon sprite address (#R$657E or #R$663E)
;   IY Hexagons screen addresses (#R$673A or #R$675E)
@label=*Screen_Hexagons_Loop
c$7C73 LD L,(IY+$00)   ; {#REGhl points to hexagon/token screen address
 $7C76 LD H,(IY+$01)   ; }
 $7C79 CALL $6E0F      ; apply color to hexagon/token area           
 $7C7C PUSH DE         ; store hexagon/token sprite address          
 $7C7D CALL $6DE1      ; draw hexagon sprite                         
 $7C80 POP DE          ; restore hexagon/token sprite address        
 $7C81 INC IY          ; {move #REGiy to next hexagon/token screen address
 $7C83 INC IY          ; }
 $7C85 DJNZ $7C73      ; repeat for each hexagon/token
 $7C87 RET             ;

; Clean Text Area
;
; Used by the routines at #R$79F7, #R$7AA3 and #R$7B5A.
; .
; Clean the text attributes area of "How to play" screens.
;
; I:HL Text area attributes address
@label=*Screen_Clear_Text
c$7C88 LD BC,$0030     ; length of attributes area: width x height (in bytes)
@label=Screen_ClearText_Loop
*$7C8B LD DE,$0018     ; displacement for each text row                  
 $7C8E ADD HL,DE       ; add displacement to text area attributes address
 $7C8F LD D,H          ; {#REGde points to text area attributes address
 $7C90 LD E,L          ; }
 $7C91 LD (HL),$00     ; set attributes color (black) for 1st byte of current row 
 $7C93 INC DE          ; move #REGde to next byte attribute address
 $7C94 LDI             ; {set attributes color for the rest of bytes of current row
 $7C96 LDI             ;
 $7C98 LDI             ;
 $7C9A LDI             ;
 $7C9C LDI             ;
 $7C9E LDI             ;
 $7CA0 LDI             ;
 $7CA2 LDI             ; }
 $7CA4 JP PE,$7C8B     ; repeat for each row
 $7CA7 RET             ;

; Cyan positions
;
; Initialized by the routine at #R$6C4B. Read by the routines at #R$6D36, #R$6CEC, #R$6F7F, #R$6FB4, #R$700E, #R$7052, #R$70AC, #R$7103, #R$7141
; and #R$717D. Updated by the routine at #R$70F7, #R$70FD.
; .
; 256-aligned memory area reserved for cyan positions.
@label=CYAN_POSITIONS
g$7D00 DEFS 256

; Red positions
;
; Initialized by the routine at #R$6C4B. Read by the routines at #R$7103, #R$71B5 and #R$71F7. Updated by the routines at #R$70F7 and #R$70FD.
; .
; 256-aligned memory area reserved for red positions.
@label=RED_POSITIONS
g$7E00 DEFS 256

; Candidates
;
; Initialized by the routine at #R$6CEC. Read by the routines at #R$6F7F, #R$6FB4 and #R$7052. Updated by the routine at #R$7524.
; .
; 256-aligned memory area reserved to store candidates.
@label=CANDIDATES
g$7F00 DEFS 256
